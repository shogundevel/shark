###############################################################################
### Copyright #################################################################
## 
## Copyright 2022 Daniel Alvarez <shogundevel@gmail.com>
## 
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation files
## (the "Software"), to deal in the Software without restriction,
## including without limitation the rights to use, copy, modify, merge,
## publish, distribute, sublicense, and/or sell copies of the Software,
## and to permit persons to whom the Software is furnished to do so,
## subject to the following conditions:
## 
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
## 
###############################################################################

import "system/data.api"
import "sharkg/backend.api"

class shark_backend_c (shark_backend)
    var indent_level: int
    var out: FILE
    var buf: strbuf
    var init: bool
    var cond: str
    var step: str
    var temp: int
    var type_context: shark_custom_type
    var function_context: shark_function
    var impl_table: strmap
    var exp: str
    var exp_left: str
    var exp_base: str
    var call_stack: list
    var call_args: list
    
    function shark_backend_c()
    function indent()
    function dedent()
    function write_indent()
    function write_type(type: shark_type, real: bool)
    function write_type_name(type: shark_type)
    function push()
    function exit_assign()
    function write_args()
    function exit_call()

class shark_backend_c
    function shark_backend_c()
        self.indent_level = 0
        self.out = null
        self.buf = null
        self.init = false
        self.cond = null
        self.step = null
        self.temp = 0
        self.type_context = null
        self.function_context = null
        self.impl_table = null
        self.exp = null
        self.exp_left = null
        self.exp_base = null
        self.call_stack = null
        self.call_args = null
    
    function indent()
        self.indent_level += 1
    
    function dedent()
        self.indent_level -= 1
    
    function write_indent()
        for i: int = 0, i < self.indent_level, i++ do
            self.out.write("    ")
    
    function begin(out: str)
        self.buf = new strbuf ()
        self.out = open(out, 'w')
        if self.out == null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.out.write("#include \"shark.h\"\n")
        self.call_stack = new list ()
    
    function close()
        self.out.close()
    
    function write_type(type: shark_type, real: bool)
        if type == shark_basic_type_any then
            self.buf.write("void *")
        else if instanceof(type, shark_basic_type) then
            self.buf.write("shark_")
            self.buf.write(cast(type, shark_basic_type).name)
        else if instanceof(type, shark_custom_type) then
            self.buf.write("shark_type_")
            self.buf.write(cast(type, shark_custom_type).name)
        else
            var child: shark_type = cast(type, shark_array_type).type
            if instanceof(child, shark_basic_type) and child != shark_basic_type_str then
                self.buf.write("shark_")
                self.buf.write(cast(child, shark_basic_type).name)
                self.buf.write("_array")
            else
                self.buf.write("shark_object_array")
            if real then
                self.buf.write("*")
    
    function write_type_name(type: shark_type)
        self.write_type(type, true)
    
    function enter_type_decl(type: shark_custom_type)
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        var type_name: str = self.buf.get()
        
        self.buf.write("shark_class_")
        self.buf.write(type.name)
        var class_name: str = self.buf.get()
        
        self.out.write("typedef struct _")
        self.out.write(type_name)
        self.out.write(" *")
        self.out.write(type_name)
        self.out.write(";\n")
        
        self.out.write("typedef struct _")
        self.out.write(class_name)
        self.out.write(" ")
        self.out.write(class_name)
        self.out.write(";\n")
        
        self.type_context = type
    
    function exit_type_decl()
        var type: shark_custom_type = self.type_context
        
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        var type_name: str = self.buf.get()
        
        self.buf.write("shark_class_")
        self.buf.write(type.name)
        var class_name: str = self.buf.get()
        
        self.out.write("struct _")
        self.out.write(type_name)
        self.out.write("\n{\n")
        
        self.indent()
        self.write_indent()
        if type.parent != null then
            self.out.write("struct _shark_type_")
            self.out.write(type.parent.name)
            self.out.write(" __super;\n")
        else
            self.out.write("shark_object __super;\n")
        
        for i: int = 0, i < type.fields.size(), i++ do
            var field: shark_variable = cast(type.fields.get(i), shark_variable)
            self.write_type_name(field.type)
            self.write_indent()
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(field.name)
            self.out.write(";\n")
        
        self.dedent()
        self.out.write("};\n")
        
        self.out.write("struct _")
        self.out.write(class_name)
        self.out.write("\n{\n")
        
        self.indent()
        self.write_indent()
        if type.parent != null then
            self.out.write("shark_class_")
            self.out.write(type.parent.name)
            self.out.write(" __super;\n")
        else
            self.out.write("shark_object_class __super;\n")
        
        for i: int = 0, i < type.methods.size(), i++ do
            var method: shark_function = cast(type.methods.get(i), shark_function)
            self.write_indent()
            if method.type == null then
                self.out.write("void (*")
            else
               self.write_type_name(method.type)
               self.out.write(self.buf.get())
               self.out.write(" (*")
            self.out.write(method.name)
            self.out.write(")(void *")
            for k: int = 0, k < method.arg_types.size(), k++ do
                self.out.write(", ")
                self.write_type_name(cast(method.arg_types.get(k), shark_type))
                self.out.write(self.buf.get())
            self.out.write(");\n")
        
        self.dedent()
        self.out.write("};\nextern ")
        self.out.write(class_name)
        self.out.write(" shark_impl_")
        self.out.write(type.name)
        self.out.write(";\n")
        self.type_context = null
    
    function enter_type_impl(type: shark_custom_type)
        self.type_context = type
        self.impl_table = new strmap ()
    
    function exit_type_impl()
        var type_count: int = 0
        var call_table: str = ""
        
        for type: shark_custom_type = self.type_context, type != null, type = type.parent do
            for i: int = 0, i < type.methods.size(), i++ do
                self.buf.write(", ")
                var method: shark_function = cast(type.methods.get(i), shark_function)
                self.buf.write("shark_lib_")
                if self.impl_table.has(method.name) then
                    self.buf.write(self.type_context.name)
                else
                    self.buf.write(type.name)
                self.buf.write("_")
                self.buf.write(method.name)
            self.buf.write("}")
            self.buf.write(call_table)
            call_table = self.buf.get()
            type_count++
        
        for i: int = 0, i < type_count, i++ do
            self.buf.write("{")
        self.buf.write("{ sizeof(struct _shark_type_")
        self.buf.write(self.type_context.name)
        self.buf.write("), ")
        
        if self.type_context.parent == null then
            self.buf.write("NULL }")
        else
            self.buf.write("&shark_impl_")
            self.buf.write(self.type_context.parent.name)
            self.buf.write(" }")
        
        self.buf.write(call_table)
        
        self.out.write("shark_class_")
        self.out.write(self.type_context.name)
        self.out.write(" shark_impl_")
        self.out.write(self.type_context.name)
        self.out.write(" = ")
        self.out.write(self.buf.get())
        self.out.write(";\n")
        self.type_context = null
    
    function var_decl(name: str, type: shark_type)
        self.write_indent()
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    
    function global_var_decl(name: str, type: shark_type, value: bool)
        if not value then
            self.out.write("extern ")
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" shark_lib_")
        self.out.write(name)
        if value then
            self.out.write(" = ")
            self.out.write(self.exp)
        self.out.write(";\n")
    
    function declare_constructor(function_object: shark_function)
        self.out.write("void shark_lib_")
        self.out.write(function_object.name)
        self.out.write("_")
        self.out.write(function_object.name)
        self.out.write("(void *self")
        
        for i: int = 0, i < function_object.arg_names.size(), i++ do
            self.out.write(", ")
            self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(cast(function_object.arg_names.get(i), str))
        
        self.out.write(");\n")
        
        self.out.write("shark_type_")
        self.out.write(self.type_context.name)
        self.out.write(" shark_type_")
        self.out.write(self.type_context.name)
        self.out.write("_new(")
        
        for i: int = 0, i < function_object.arg_names.size(), i++ do
            if i != 0 then
                self.out.write(", ")
            self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(cast(function_object.arg_names.get(i), str))
        
        self.out.write(");\n")
    
    function declare_method(function_object: shark_function)
        if function_object.type != null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        
        self.out.write(" shark_lib_")
        self.out.write(self.type_context.name)
        self.out.write("_")
        self.out.write(function_object.name)
        self.out.write("(void *self")
        
        for i: int = 0, i < function_object.arg_names.size(), i++ do
            self.out.write(", ")
            self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(cast(function_object.arg_names.get(i), str))
        
        self.out.write(");\n")
    
    function declare_function(function_object: shark_function)
        if function_object.type != null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        
        self.out.write(" shark_lib_")
        self.out.write(function_object.name)
        self.out.write("(")
        
        for i: int = 0, i < function_object.arg_names.size(), i++ do
            if i != 0 then
                self.out.write(", ")
            self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(cast(function_object.arg_names.get(i), str))
        
        self.out.write(");\n")
    
    function close_function_declaration()
        shark_null_stat()
    
    function enter_function(function_object: shark_function)
        if self.type_context != null and function_object.name == self.type_context.name then
            self.out.write("shark_type_")
            self.out.write(self.type_context.name)
            self.out.write(" shark_type_")
            self.out.write(self.type_context.name)
            self.out.write("_new(")
            
            for i: int = 0, i < function_object.arg_names.size(), i++ do
                if i != 0 then
                    self.out.write(", ")
                self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(cast(function_object.arg_names.get(i), str))
            
            self.out.write(") {")
            self.indent()
            self.write_indent()
            self.out.write("shark_type_")
            self.out.write(self.type_context.name)
            self.out.write(" self = shark_object_new(&shark_impl_")
            self.out.write(self.type_context.name)
            self.out.write(");\n")
            
            self.write_indent()
            self.out.write("shark_lib_")
            self.out.write(self.type_context.name)
            self.out.write("_")
            self.out.write(self.type_context.name)
            self.out.write("(self")
            
            for i: int = 0, i < function_object.arg_names.size(), i++ do
                self.out.write(", ")
                self.out.write(cast(function_object.arg_names.get(i), str))
            
            self.out.write(");\n")
            self.write_indent()
            self.out.write("return self;\n")
            self.dedent()
            self.out.write("}\n")
        
        if function_object.type != null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        
        self.out.write(" shark_lib_")
        
        if self.type_context != null then
            self.impl_table.set(function_object.name, 0)
            self.out.write(self.type_context.name)
            self.out.write("_")
        
        self.out.write(function_object.name)
        self.out.write("(")
        
        if self.type_context != null then
            self.out.write("void *self")
            if function_object.arg_names.size() != 0 then
                self.out.write(", ")
        
        for i: int = 0, i < function_object.arg_names.size(), i++ do
            if i != 0 then
                self.out.write(", ")
            self.write_type_name(cast(function_object.arg_types.get(i), shark_type))
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(cast(function_object.arg_names.get(i), str))
        
        self.out.write(") {\n")
    
    function exit_function()
        self.out.write("}\n")
    
    function inline_stat(code: str)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    
    function enter_block()
        self.indent()
    
    function empty_block()
        shark_null_stat()
    
    function exit_block()
        self.dedent()
    
    function if_stat()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    
    function enter_else_if()
        self.write_indent()
        self.out.write("} else {\n")
    
    function else_if()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    
    function else_clause()
        self.write_indent()
        self.out.write("} else {\n")
    
    function close_if()
        self.write_indent()
        self.out.write(self.buf.get())
        self.out.write("}\n")
    
    function close_else_if()
        self.buf.write("}")
    
    function enter_while()
        shark_null_stat()
    
    function while_stat()
        self.write_indent()
        self.out.write("while (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    
    function exit_while()
        self.write_indent()
        self.out.write("}\n")
    
    function enter_for()
        self.init = false
        self.cond = null
        self.call_stack.push(self.step)
        self.step = null
    
    function push()
        self.exp_base = self.exp_left
        self.exp_left = self.exp
    
    function for_init(name: str, type: shark_type)
        self.init = true
        self.write_indent()
        self.out.write("do {\n")
        self.write_indent()
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    
    function for_cond()
        self.cond = self.exp
    
    function for_step()
        self.step = self.exp
    
    function for_stat()
        self.write_indent()
        self.out.write("while (")
        if self.cond != null then
            self.out.write(self.cond)
        else
            self.out.write("true")
        self.out.write(") {\n")
    
    function exit_for()
        if self.step != null then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write(self.step)
            self.out.write(";\n")
        self.write_indent()
        if self.init then
            self.out.write("}} while (false);")
        else
            self.out.write("}\n")
        self.step = cast(self.call_stack.pop(), str)
    
    function break_stat()
        self.write_indent()
        self.out.write("break;\n")
    
    function continue_stat()
        self.write_indent()
        self.out.write("continue;\n")
    
    function return_stat(value: bool)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write(";\n")
        else
            self.out.write("return;\n")
    
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write(";\n")
    
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    
    function exit_assign()
        self.exp_base = cast(self.call_stack.pop(), str)
        self.exp_left = cast(self.call_stack.pop(), str)
    
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    
    function binary_op(op: str, strop: bool, objop: bool)
        if strop then
            if op == "!=" then
                self.buf.write("!")
            self.buf.write("shark_str_equals(")
            self.buf.write(self.exp_left)
            self.buf.write(", ")
            self.buf.write(self.exp)
            self.buf.write(")")
        else if objop then
            self.buf.write("((void *) ")
            self.buf.write(self.exp_left)
            self.buf.write(") ")
            self.buf.write(op)
            self.buf.write(" ((void *) ")
            self.buf.write(self.exp)
            self.buf.write(")")
        else
            if op == "and" then
                op = "&&"
            if op == "or" then
                op = "||"
            self.buf.write(self.exp_left)
            self.buf.write(op)
            self.buf.write(self.exp)
        self.exp = self.buf.get()
        self.exp_left = cast(self.call_stack.pop(), str)
    
    function unary_op(op: str)
        if op == "not" then
            op = "!"
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp = self.buf.get()
    
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    
    function inc_index(op: str)
        self.buf.write(self.exp_left)
        self.buf.write("->data[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.exp_base = cast(self.call_stack.pop(), str)
        self.exp_left = cast(self.call_stack.pop(), str)
        self.exp = self.buf.get()
    
    function set_index(op: str)
        self.buf.write(self.exp_base)
        self.buf.write("->data[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_base = cast(self.call_stack.pop(), str)
        self.exp_left = cast(self.call_stack.pop(), str)
        self.exp = self.buf.get()
        self.exit_assign()
    
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("->data[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_base = cast(self.call_stack.pop(), str)
        self.exp_left = cast(self.call_stack.pop(), str)
        self.exp = self.buf.get()
    
    function call_method(function_object: shark_function)
        self.buf.write("((shark_class_")
        self.buf.write(function_object.source_type.name)
        self.buf.write(" *) ((shark_object *) ")
        self.buf.write(self.exp_left)
        self.buf.write(")->type)->")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.buf.write(self.exp_left)
        if self.call_args.size() != 0 then
            self.buf.write(", ")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp = self.buf.get()
    
    function write_args()
        if self.call_args.size() != 0 then
            self.buf.write(cast(self.call_args.get(0), str))
            for i: int = 1, i < self.call_args.size(), i++ do
                self.buf.write(", ")
                self.buf.write(cast(self.call_args.get(i), str))
    
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args = new list ()
    
    function exit_call()
        self.call_args = cast(self.call_stack.pop(), list)
        self.exp_base = cast(self.call_stack.pop(), str)
        self.exp_left = cast(self.call_stack.pop(), str)
    
    function push_arg()
        self.call_args.push(self.exp)
    
    function inc_field(field: shark_variable, op: str)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.buf.write(op)
        self.exp = self.buf.get()
    
    function set_field(field: shark_variable, op: str)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp_left)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp = self.buf.get()
        self.exit_assign()
    
    function get_field(field: shark_variable)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.exp = self.buf.get()
    
    function inc_local(name: str, op: str)
        self.buf.write(name)
        self.buf.write(op)
        self.exp = self.buf.get()
    
    function set_local(name: str, op: str)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp = self.buf.get()
        self.exit_assign()
    
    function get_local(name: str)
        self.exp = name
    
    function call_function(name: str)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp = self.buf.get()
    
    function inc_global(name: str, op: str)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.inc_local(self.buf.get(), op)
    
    function set_global(name: str, op: str)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.set_local(self.buf.get(), op)
    
    function get_global(name: str)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.exp = self.buf.get()
    
    function self_exp()
        self.buf.write("((shark_type_")
        self.buf.write(self.type_context.name)
        self.buf.write(") self)")
        self.exp = self.buf.get()
    
    function sizeof_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write("->size)")
        self.exp = self.buf.get()
    
    function array_new(type: shark_type)
        self.write_type(type, false)
        self.buf.write("_new(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp = self.buf.get()
    
    function object_new(type: shark_custom_type)
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        self.buf.write("_new(")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp = self.buf.get()
    
    function instanceof_exp(type: shark_custom_type)
        self.buf.write("shark_object_instanceof(")
        self.buf.write(self.exp)
        self.buf.write(", &shark_impl_")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp = self.buf.get()
    
    function cast_exp(type: shark_type)
        self.buf.write("((")
        self.write_type_name(type)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp = self.buf.get()
    
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp = self.buf.get()
    
    function null_exp()
        self.exp = "NULL"
    
    function true_exp()
        self.exp = "true"
    
    function false_exp()
        self.exp = "false"
    
    function int_exp(value: str)
        self.exp = value
    
    function float_exp(value: str)
        self.exp = value
    
    function char_exp(value: str)
        self.exp = value
    
    function str_exp(value: str)
        var buf: strbuf = new strbuf ()
        buf.write("shark_string_")
        buf.write(itos(self.temp))
        self.temp++
        
        var name: str = buf.get()
        var size: int = 0
        var iter: striter = new striter (value)
        
        while not iter.empty() do
            var c: char = iter.next()
            if c == '"' then
                continue
            else if c == '\\' then
                iter.next()
            size++
        
        self.out.write("static struct _shark_str ")
        self.out.write(name)
        self.out.write(" = SHARK_STR_LIT(")
        self.out.write(itos(size))
        self.out.write(", ")
        self.out.write(value)
        self.out.write(");\n")
        self.buf.write("&")
        self.buf.write(name)
        self.exp = self.buf.get()
