
lexical analysis
================

dec_lit = '0|([1-9]+[0-9]*)'

int_lit = [ '-' ] dec_lit
float_lit = [ '-' ] '[dec_lit].[0-9]+'

escape_char = '[0|n|\'|\"]'
escape = "\\escape_char"
char = '~[escape]'

char_lit = '\'(char|escape)\''
str_lit = '\"(char|escape)*\"'

name = '[a-zA-Z_]+[0-9a-zA-Z_]*'

EOL = ';' | '\n'
SEOL = [ '\n' ]

indent
dedent

top level
=========

source_file = { decl }

decl = import
     | class
     | var
     | function

import = "import" str_lit EOL

type definition
===============

class = "class" name [ '(' ( custom_type | "object" ) ')' ] EOL class_body
class_body = indent { var | function } dedent

variables
=========

var = "var" name ':' type [ '=' exp ] EOL

functions
=========

function = "function" name args [ '->' type ] EOL [ indented_block ]
args = '(' [ name ':' type { ',' name ':' type } ] ')'

types
=====

basic_type = "bool"
           | "int"
           | "float"
           | "char"
           | "str"
           | "object"

custom_type = name

type = basic_type
     | custom_type
     | '[' ']' type

statements
==========

block = statement | indented_block
indented_block = SEOL indent { var | statement } dedent

statement = if
          | while
          | for
          | simple_statement

conditional branches
--------------------

if = "if" exp "then" block [ "else" ( if | block ) ]

loops
-----

while = "while" exp "do" block
for = "for" init ',' [ exp ] ',' [ assign ] "do" block
init = [ name ':' type '=' exp ]

simple statements
-----------------

simple_statement = break
                 | continue
                 | return
                 | assign_stat

break = "break" EOL
continue = "continue" EOL

return = "return" [ exp ] EOL

assign_stat = assign EOL
assign = exp [ ( '++' | '--' ) | ( assign_op exp ) ]

assign_op = '='
          | '*=' | '/=' | '%='
          | '+=' | '-='

expressions
===========

binary_op = unary_op
          | binary_op ( '*' | '/' | '%'
                      > '+' | '-'
                      > '<' | '<=' | '>' | '>='
                      > '==' | '!='
                      > '<<' | '>>'
                      > '&' | '|' | '^'
                      > 'and'
                      > 'or' ) unary_op

unary_op = post_op
         | ( "not"
           | "-"
           | "~" ) unary_op

post_op = primary_exp
        | post_op ( '(' [ exp { ',' exp } ] ')'
                  | '[' exp ']'
                  | '.' name )

primary_exp = literal
            | name
            | "self"
            | "sizeof" '(' exp ')'
            | "new" [ '[' exp ']' ] type [ '(' [ exp { ',' exp } ] ')' ]
            | "instanceof" '(' exp ',' custom_type ')'
            | "cast" '(' exp ',' type ')'
            | '(' exp ')'

literal = "null"
        | "true"
        | "false"
        | int_lit
        | float_lit
        | char_lit
        | str_lit

exp = binary_op
