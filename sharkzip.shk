################################################################################
### Copyright ##################################################################
## 
## Copyright 2022 Daniel Alvarez <shogundevel@gmail.com>
## 
## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation files
## (the "Software"), to deal in the Software without restriction,
## including without limitation the rights to use, copy, modify, merge,
## publish, distribute, sublicense, and/or sell copies of the Software,
## and to permit persons to whom the Software is furnished to do so,
## subject to the following conditions:
## 
## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
## IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
## CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
## SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
## 
################################################################################

import system.io: puts, printf, open
import system.path: join, listdir, mkdir, get_tail
import system.util: pop, extend
import system.string: encode, decode, concat, bytes

var OBJ_FILE = 67324752
var OBJ_DIRC = 33639248
var OBJ_DIRE = 101010256

var OBJ_POLY = 3988292384
var OBJ_MASK = 4294967295

function crc32(data)
    var crc = OBJ_MASK
    for byte in range(data.tell()) do
        crc = crc ^ data.get(byte)
        for bit in range(8) do
            if (crc & 1) != 0 then
                crc = (crc ~> 1) ^ OBJ_POLY
            else
                crc = (crc ~> 1)
    return (~crc) & OBJ_MASK

function write_file(buffer, name, file)
    var head_data = new bytes ()
    var name_data = encode(name)
    var file_data = new bytes ()
    
    head_data.put_int(OBJ_FILE)
    head_data.put_short(1)      # min version
    head_data.put_short(0)      # bit flag
    head_data.put_short(0)      # compression method
    head_data.put_short(0)      # time
    head_data.put_short(0)      # date
    
    if file != null then
        while true do
            var raw_data = file.read(256)
            file_data.puts(raw_data)
            if raw_data.tell() != 256 then
                break
    
    var crc = crc32(file_data)
    
    head_data.put_int(crc)                  # crc32
    head_data.put_int(file_data.tell())     # size
    head_data.put_int(file_data.tell())     # size
    head_data.put_short(name_data.tell())   # name_size
    head_data.put_short(0)                  # dummy
    head_data.puts(name_data)               # name_data
    
    if file != null then
        file.close()
    
    buffer.puts(head_data)
    buffer.puts(file_data)
    
    return [crc, file_data.tell(), name, head_data.tell() + file_data.tell()]

function write_dir(buffer, name, path)
    var child_data = [ write_file(buffer, concat(name, "/"), null) ]
    var dir_data = listdir(path)
    if dir_data == null then
        return
    for child in dir_data do
        if child == "." or child == ".." then
            continue
        var child_path = join(path, child)
        var child_name = join(name, child)
        var file = open(child_path, "rb")
        if file == null then
            extend(child_data, write_dir(buffer, child_name, child_path))
        else
            child_data << write_file(buffer, child_name, file)
    return child_data

function zip(source, target)
    var output = open(target, "wb")
    
    if output == null then
        printf("can't open output file '%' for writting, operation aborted.", [target])
        return
    
    var data = write_dir(output, get_tail(source), source)
    var offset = 0
    var head_data = new bytes ()
    
    for head in data do
        var name_data = encode(head[2])
        head_data.put_int(OBJ_DIRC)
        head_data.put_short(1)      # version made by
        head_data.put_short(1)      # min version
        head_data.put_short(0)      # bit flag
        head_data.put_short(0)      # compression method
        head_data.put_short(0)      # time
        head_data.put_short(0)      # date
        head_data.put_int(head[0])              # crc32
        head_data.put_int(head[1])              # size
        head_data.put_int(head[1])              # size
        head_data.put_short(name_data.tell())   # name_size
        head_data.put_short(0)                  # dummy
        head_data.put_short(0)                  # dummy
        head_data.put_short(0)                  # disk
        head_data.put_short(0)                  # file attr
        head_data.put_int(0)                    # file attr
        head_data.put_int(offset)               # offset
        head_data.puts(name_data)               # name_data
        offset += head[3]
    
    var head_size = head_data.tell()
    
    head_data.put_int(OBJ_DIRE)
    head_data.put_short(0)      # disk
    head_data.put_short(0)      # disk central
    head_data.put_short(sizeof(data))   # header count
    head_data.put_short(sizeof(data))   # header count
    head_data.put_int(head_size)        # header size
    head_data.put_int(offset)           # header offset
    head_data.put_short(0)              # dummy
    
    output.puts(head_data)
    output.close()

function main(args)
    if sizeof(args) != 3 then
        printf("%\n", [crc32(encode("123456789"))])
        puts("usage: zip <source> <target>\n")
        puts("\tzip a <source> directory to <target> zip archive.\n")
        puts("\tNOTE: the resulting archive is compatible with any standard zip file program and uses no compression method.\n")
        return
    var source = args[1]
    var target = args[2]
    zip(source, target)
