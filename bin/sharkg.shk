function __shark_array_new(size)
    var data = [ ]
    for _ in range(size) do
        data << null
    return data
function shark_path_get_base(path)
    var iter = new striter(path)
    var last = iter.tell()
    while not iter.empty() do
        var c = iter.next()
        if c=='\\' or c=='/' then
            last=iter.tell()
    iter.seek(0)
    var buffer = new strbuf()
    while iter.tell()!=last do
        buffer.put(iter.next())
    return buffer.get()
function shark_path_join(x, y)
    var buffer = new strbuf()
    var iter = new striter(x)
    var last = '\0'
    while not iter.empty() do
        last=iter.next()
        buffer.put(last)
    if last!='/' and last!='\\' and last!='\0' then
        buffer.put('/')
    buffer.write(y)
    return buffer.get()
class shark_token
    function init(lineno, type, value)
        self.shark_token(lineno, type, value)
    function shark_token(lineno, type, value)
        self.lineno=lineno
        self.type=type
        self.value=value
var shark_lexer_keywords_list = null
var shark_lexer_keywords_map = null
function shark_lexer_init_keywords()
    shark_lexer_keywords_map=shark_lexer_keywords_map
    if shark_lexer_keywords_map==null then
        shark_lexer_keywords_list=__shark_array_new(35)
        shark_lexer_keywords_list[0]="import"
        shark_lexer_keywords_list[1]="define"
        shark_lexer_keywords_list[2]="class"
        shark_lexer_keywords_list[3]="var"
        shark_lexer_keywords_list[4]="function"
        shark_lexer_keywords_list[5]="bool"
        shark_lexer_keywords_list[6]="int"
        shark_lexer_keywords_list[7]="float"
        shark_lexer_keywords_list[8]="char"
        shark_lexer_keywords_list[9]="str"
        shark_lexer_keywords_list[10]="object"
        shark_lexer_keywords_list[11]="if"
        shark_lexer_keywords_list[12]="then"
        shark_lexer_keywords_list[13]="else"
        shark_lexer_keywords_list[14]="select"
        shark_lexer_keywords_list[15]="case"
        shark_lexer_keywords_list[16]="while"
        shark_lexer_keywords_list[17]="do"
        shark_lexer_keywords_list[18]="for"
        shark_lexer_keywords_list[19]="in"
        shark_lexer_keywords_list[20]="break"
        shark_lexer_keywords_list[21]="continue"
        shark_lexer_keywords_list[22]="return"
        shark_lexer_keywords_list[23]="and"
        shark_lexer_keywords_list[24]="or"
        shark_lexer_keywords_list[25]="not"
        shark_lexer_keywords_list[26]="self"
        shark_lexer_keywords_list[27]="sizeof"
        shark_lexer_keywords_list[28]="new"
        shark_lexer_keywords_list[29]="instanceof"
        shark_lexer_keywords_list[30]="cast"
        shark_lexer_keywords_list[31]="null"
        shark_lexer_keywords_list[32]="true"
        shark_lexer_keywords_list[33]="false"
        shark_lexer_keywords_list[34]="inline"
        shark_lexer_keywords_map=new strmap()
        if true then
            var i = 0
            while i<sizeof(shark_lexer_keywords_list) do
                shark_lexer_keywords_map.set(shark_lexer_keywords_list[i], i)
                i+=1
class shark_lexer
    function init(filename, source)
        self.shark_lexer(filename, source)
    function shark_lexer(filename, source)
        shark_lexer_init_keywords()
        self.filename=filename
        self.source=source
        self.lineno=1
        self.current_char='\0'
        self.next()
        self.token=new shark_token(0, null, null)
        self.buffer=new strbuf()
        self.indent_token=new shark_token(0, "indent", "indent")
        self.dedent_token=new shark_token(0, "dedent", "dedent")
        self.indent_stack=__shark_array_new(256)
        self.indent_depth=1
        self.indent_level=0
        self.indent_stack[0]=self.indent_level
        self.dedent_count=0
        self.post_indent=false
        self.delimiter_count=0
        self.empty_line=true
    function error(message)
        write("[error] file '")
        write(self.filename)
        write("', line ")
        write(itos(self.lineno))
        write(": ")
        write(message)
        write("\n")
        exit(EXIT_FAILURE)
    function emit(type, value)
        self.token.lineno=self.lineno
        self.token.type=type
        self.token.value=value
        if self.empty_line then
            self.empty_line=false
            if self.delimiter_count==0 then
                var indent = self.indent()
                if indent!=null then
                    return indent
        return self.token
    function indent()
        var indent_level = self.indent_stack[self.indent_depth-1]
        if self.indent_level>indent_level then
            self.indent_stack[self.indent_depth]=self.indent_level
            self.indent_depth+=1
            if self.indent_depth==255 then
                self.error("max indentation depth reached.")
            return self.emit_indent()
        else if self.indent_level==indent_level then
            return null
        else
            while self.indent_level<indent_level do
                self.dedent_count+=1
                self.indent_depth-=1
                indent_level=self.indent_stack[self.indent_depth-1]
            if self.indent_level!=indent_level then
                self.error("inconsistent indentation")
            return self.emit_dedent()
    function emit_indent()
        self.post_indent=true
        self.indent_token.lineno=self.lineno
        return self.indent_token
    function emit_dedent()
        self.post_indent=true
        self.dedent_count-=1
        self.dedent_token.lineno=self.lineno
        return self.dedent_token
    function next()
        var value = self.current_char
        if self.source.at_end() then
            self.current_char='\0'
        else
            self.current_char=self.source.fetch()
            if self.current_char=='\0' then
                self.error("unexpected null character.")
        return value
    function match(value)
        if self.current_char==value then
            self.next()
            return true
        else
            return false
    function skip_until(c, consume)
        while self.current_char!=c do
            if self.current_char=='\n' then
                self.lineno+=1
            else if self.current_char=='\0' then
                return
            self.next()
        if consume then
            self.next()
    function escape()
        var c = self.next()
        if (c=='0' or c=='r' or c=='n' or c=='t' or c=='\\' or c=='"' or c=='\'') then
            return c
        else
            self.error("invalid escape sequence.")
            return '\0'
    function scan_name()
        while isident(self.current_char) do
            self.buffer.put(self.next())
        var value = self.buffer.get()
        if shark_lexer_keywords_map.has(value) then
            return self.emit("keyword", shark_lexer_keywords_list[shark_lexer_keywords_map.get(value)])
        else
            return self.emit("name", value)
    function scan_number(start)
        self.buffer.put(start)
        if start=='0' and isdigit(self.current_char) then
            self.error("unexpected digit character after zero.")
        while isdigit(self.current_char) do
            self.buffer.put(self.next())
        if self.match('.') then
            self.buffer.put('.')
            if not isdigit(self.current_char) then
                self.error("expected at least one digit after dot.")
            self.buffer.put(self.next())
            while isdigit(self.current_char) do
                self.buffer.put(self.next())
            return self.emit("float", self.buffer.get())
        return self.emit("int", self.buffer.get())
    function scan()
        if self.dedent_count>0 then
            return self.emit_dedent()
        else if self.post_indent then
            self.post_indent=false
            return self.token
        if true then
            while true do
                var c = self.next()
                if c==' ' or c=='\t' or c=='\r' then
                    continue
                else if c=='\n' then
                    self.indent_level=0
                    while self.match(' ') do
                        self.indent_level+=1
                    var newline = null
                    if not self.empty_line and self.delimiter_count==0 then
                        newline=self.emit("newline", "newline")
                    self.lineno+=1
                    self.empty_line=true
                    if newline!=null then
                        return newline
                    else
                        continue
                else if c=='\0' then
                    self.indent_level=0
                    var indent = self.indent()
                    self.emit("EOF", null)
                    if indent!=null then
                        return indent
                    else
                        return self.token
                else if c=='#' then
                    self.skip_until('\n', false)
                else if c==':' then
                    return self.emit("delimiter", ":")
                else if c==';' then
                    return self.emit("delimiter", ";")
                else if c=='.' then
                    return self.emit("delimiter", ".")
                else if c==',' then
                    return self.emit("delimiter", ",")
                else if c=='[' then
                    self.delimiter_count+=1
                    return self.emit("delimiter", "[")
                else if c==']' then
                    self.delimiter_count-=1
                    return self.emit("delimiter", "]")
                else if c=='{' then
                    self.delimiter_count+=1
                    return self.emit("delimiter", "{")
                else if c=='}' then
                    self.delimiter_count-=1
                    return self.emit("delimiter", "}")
                else if c=='(' then
                    self.delimiter_count+=1
                    return self.emit("delimiter", "(")
                else if c==')' then
                    self.delimiter_count-=1
                    return self.emit("delimiter", ")")
                else if c=='*' then
                    if self.match('=') then
                        return self.emit("assign", "*=")
                    else
                        return self.emit("operator", "*")
                else if c=='/' then
                    if self.match('=') then
                        return self.emit("assign", "/=")
                    else
                        return self.emit("operator", "/")
                else if c=='%' then
                    if self.match('=') then
                        return self.emit("assign", "%=")
                    else
                        return self.emit("operator", "%")
                else if c=='+' then
                    if self.match('+') then
                        return self.emit("operator", "++")
                    else if self.match('=') then
                        return self.emit("assign", "+=")
                    else
                        return self.emit("operator", "+")
                else if c=='-' then
                    if isdigit(self.current_char) then
                        self.buffer.put('-')
                        return self.scan_number(self.next())
                    else if self.match('>') then
                        return self.emit("delimiter", "->")
                    else if self.match('-') then
                        return self.emit("operator", "--")
                    else if self.match('=') then
                        return self.emit("assign", "-=")
                    else
                        return self.emit("operator", "-")
                else if c=='<' then
                    if self.match('=') then
                        return self.emit("operator", "<=")
                    else if self.match('<') then
                        return self.emit("operator", "<<")
                    else
                        return self.emit("operator", "<")
                else if c=='>' then
                    if self.match('=') then
                        return self.emit("operator", ">=")
                    else if self.match('>') then
                        return self.emit("operator", ">>")
                    else
                        return self.emit("operator", ">")
                else if c=='=' then
                    if self.match('=') then
                        return self.emit("operator", "==")
                    else
                        return self.emit("assign", "=")
                else if c=='!' then
                    if self.match('=') then
                        return self.emit("operator", "!=")
                    else
                        return self.emit("operator", "!")
                else if c=='~' then
                    return self.emit("operator", "~")
                else if c=='&' then
                    return self.emit("operator", "&")
                else if c=='|' then
                    return self.emit("operator", "|")
                else if c=='^' then
                    return self.emit("operator", "^")
                else if c=='"' then
                    self.buffer.put('"')
                    while not self.match('"') do
                        var c2 = self.next()
                        self.buffer.put(c2)
                        if c2=='\\' then
                            self.buffer.put(self.escape())
                        else if c2=='\n' then
                            self.error("unexpected EOL while scanning string literal.")
                    self.buffer.put('"')
                    return self.emit("str", self.buffer.get())
                else if c=='\'' then
                    self.buffer.put('\'')
                    if self.match('\\') then
                        self.buffer.put('\\')
                        self.buffer.put(self.escape())
                    else if self.match('\'') then
                        self.error("expected at least one character in char literal (try escaping the quote with \\).")
                    else if self.match('\n') then
                        self.error("unexpected EOL while scanning character literal.")
                    else
                        self.buffer.put(self.next())
                    if not self.match('\'') then
                        self.error("expected a quote to close character literal.")
                    self.buffer.put('\'')
                    return self.emit("char", self.buffer.get())
                else
                    if isalpha(c) or c=='_' then
                        self.buffer.put(c)
                        return self.scan_name()
                    else if isdigit(c) then
                        return self.scan_number(c)
                    else
                        self.error("invalid character.")
class shark_namespace
    function init(parent)
        self.shark_namespace(parent)
    function shark_namespace(parent)
        self.parent=parent
        self.table=new strmap()
        self.data=new list()
    function add(name, value)
        self.table.set(name, self.data.size())
        self.data.push(value)
    function has(name)
        return self.table.has(name)
    function get(name)
        return self.data.get(self.table.get(name))
class shark_type
    function init()
        self.shark_type()
    function shark_type()
        shark_null_stat()
    function equals(other)
        return self==other
    function get_cast(other)
        return self.equals(other)
class shark_basic_type(shark_type)
    function init(name)
        self.shark_basic_type(name)
    function shark_basic_type(name)
        self.name=name
    function get_cast(other)
        return other==self or (self==shark_basic_type_str and other==shark_basic_type_void)
class shark_basic_any_type(shark_basic_type)
    function init()
        self.shark_basic_any_type()
    function shark_basic_any_type()
        self.name="object"
    function get_cast(other)
        return (other==self or instanceof(other, shark_custom_type) or instanceof(other, shark_array_type) or other==shark_basic_type_str or other==shark_basic_type_void)
var shark_basic_type_void = null
var shark_basic_type_bool = null
var shark_basic_type_int = null
var shark_basic_type_float = null
var shark_basic_type_char = null
var shark_basic_type_str = null
var shark_basic_type_any = null
var shark_compiler_basic_types = null
class shark_custom_type(shark_type)
    function init(name, parent)
        self.shark_custom_type(name, parent)
    function shark_custom_type(name, parent)
        self.name=name
        self.parent=parent
        self.implemented=false
        self.namespace=new shark_namespace(null)
        self.fields=new list()
        self.methods=new list()
        self.constructor=null
        if parent!=null then
            if true then
                var i = 0
                while i<parent.namespace.data.size() do
                    var value = parent.namespace.data.get(i)
                    self.namespace.add(shark_object_get_name(value), value)
                    i+=1
            self.constructor=parent.constructor
    function issubtype(other)
        var parent = self.parent
        while parent!=null do
            if parent==other then
                return true
            parent=parent.parent
        return false
    function get_cast(other)
        if instanceof(other, shark_custom_type) then
            return other==self or other.issubtype(self)
        else
            return other==shark_basic_type_void
class shark_array_type(shark_type)
    function init(type)
        self.shark_array_type(type)
    function shark_array_type(type)
        self.type=type
    function equals(other)
        if not instanceof(other, shark_array_type) then
            return false
        else
            return self.type.equals(other.type)
    function get_cast(other)
        return self.equals(other) or other==shark_basic_type_void
function shark_object_get_name(value)
    if instanceof(value, shark_variable) then
        return value.name
    else
        return value.name
class shark_variable
    function init(name, type)
        self.shark_variable(name, type)
    function shark_variable(name, type)
        self.name=name
        self.type=type
        self.source_type=null
class shark_function
    function init(name, source_type, arg_names, arg_types, type)
        self.shark_function(name, source_type, arg_names, arg_types, type)
    function shark_function(name, source_type, arg_names, arg_types, type)
        self.name=name
        self.root_type=source_type
        self.source_type=source_type
        self.arg_names=arg_names
        self.arg_types=arg_types
        self.type=type
        self.implemented=false
function shark_null_stat()
    return null
class shark_backend
    function init()
        self.shark_backend()
    function shark_backend()
        shark_null_stat()
    function begin(out)
        shark_null_stat()
    function close()
        shark_null_stat()
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        shark_null_stat()
    function exit_type_impl()
        shark_null_stat()
    function var_decl(name, type)
        shark_null_stat()
    function global_var_decl(name, type, value)
        shark_null_stat()
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        shark_null_stat()
    function exit_function()
        shark_null_stat()
    function inline_stat(code)
        shark_null_stat()
    function enter_block()
        shark_null_stat()
    function empty_block()
        shark_null_stat()
    function exit_block()
        shark_null_stat()
    function if_stat()
        shark_null_stat()
    function enter_else_if()
        shark_null_stat()
    function else_if()
        shark_null_stat()
    function else_clause()
        shark_null_stat()
    function close_if()
        shark_null_stat()
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        shark_null_stat()
    function exit_while()
        shark_null_stat()
    function enter_for()
        shark_null_stat()
    function for_init(name, type)
        shark_null_stat()
    function for_cond()
        shark_null_stat()
    function for_step()
        shark_null_stat()
    function for_stat()
        shark_null_stat()
    function exit_for()
        shark_null_stat()
    function break_stat()
        shark_null_stat()
    function continue_stat()
        shark_null_stat()
    function return_stat(value)
        shark_null_stat()
    function assign_stat()
        shark_null_stat()
    function enter_assign()
        shark_null_stat()
    function enter_binop()
        shark_null_stat()
    function binary_op(op, strop, objop)
        shark_null_stat()
    function unary_op(op)
        shark_null_stat()
    function enter_index()
        shark_null_stat()
    function inc_index(op)
        shark_null_stat()
    function set_index(op)
        shark_null_stat()
    function get_index()
        shark_null_stat()
    function call_method(function_object)
        shark_null_stat()
    function enter_call()
        shark_null_stat()
    function push_arg()
        shark_null_stat()
    function inc_field(field, op)
        shark_null_stat()
    function set_field(field, op)
        shark_null_stat()
    function get_field(field)
        shark_null_stat()
    function inc_local(name, op)
        shark_null_stat()
    function set_local(name, op)
        shark_null_stat()
    function get_local(name)
        shark_null_stat()
    function call_function(name)
        shark_null_stat()
    function inc_global(name, op)
        shark_null_stat()
    function set_global(name, op)
        shark_null_stat()
    function get_global(name)
        shark_null_stat()
    function self_exp()
        shark_null_stat()
    function sizeof_exp()
        shark_null_stat()
    function array_new(type)
        shark_null_stat()
    function object_new(type)
        shark_null_stat()
    function instanceof_exp(type)
        shark_null_stat()
    function cast_exp(type)
        shark_null_stat()
    function nested_exp()
        shark_null_stat()
    function null_exp()
        shark_null_stat()
    function true_exp()
        shark_null_stat()
    function false_exp()
        shark_null_stat()
    function int_exp(value)
        shark_null_stat()
    function float_exp(value)
        shark_null_stat()
    function char_exp(value)
        shark_null_stat()
    function str_exp(value)
        shark_null_stat()
class shark_backend_c(shark_backend)
    function init()
        self.shark_backend_c()
    function shark_backend_c()
        self.indent_level=0
        self.out=null
        self.buf=null
        self.init=false
        self.cond=null
        self.step=null
        self.temp=0
        self.type_context=null
        self.function_context=null
        self.impl_table=null
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.out.write("#include \"shark.h\"\n")
        self.call_stack=new list()
    function close()
        self.out.close()
    function write_type(type, real)
        if type==shark_basic_type_any then
            self.buf.write("void *")
        else if instanceof(type, shark_basic_type) then
            self.buf.write("shark_")
            self.buf.write(type.name)
        else if instanceof(type, shark_custom_type) then
            self.buf.write("shark_type_")
            self.buf.write(type.name)
        else
            var child = type.type
            if instanceof(child, shark_basic_type) and child!=shark_basic_type_str then
                self.buf.write("shark_")
                self.buf.write(child.name)
                self.buf.write("_array")
            else
                self.buf.write("shark_object_array")
            if real then
                self.buf.write("*")
    function write_type_name(type)
        self.write_type(type, true)
    function enter_type_decl(type)
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        var type_name = self.buf.get()
        self.buf.write("shark_class_")
        self.buf.write(type.name)
        var class_name = self.buf.get()
        self.out.write("typedef struct _")
        self.out.write(type_name)
        self.out.write(" *")
        self.out.write(type_name)
        self.out.write(";\n")
        self.out.write("typedef struct _")
        self.out.write(class_name)
        self.out.write(" ")
        self.out.write(class_name)
        self.out.write(";\n")
        self.type_context=type
    function exit_type_decl()
        var type = self.type_context
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        var type_name = self.buf.get()
        self.buf.write("shark_class_")
        self.buf.write(type.name)
        var class_name = self.buf.get()
        self.out.write("struct _")
        self.out.write(type_name)
        self.out.write("\n{\n")
        self.indent()
        self.write_indent()
        if type.parent!=null then
            self.out.write("struct _shark_type_")
            self.out.write(type.parent.name)
            self.out.write(" __super;\n")
        else
            self.out.write("shark_object __super;\n")
        if true then
            var i = 0
            while i<type.fields.size() do
                var field = type.fields.get(i)
                self.write_type_name(field.type)
                self.write_indent()
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(field.name)
                self.out.write(";\n")
                i+=1
        self.dedent()
        self.out.write("};\n")
        self.out.write("struct _")
        self.out.write(class_name)
        self.out.write("\n{\n")
        self.indent()
        self.write_indent()
        if type.parent!=null then
            self.out.write("shark_class_")
            self.out.write(type.parent.name)
            self.out.write(" __super;\n")
        else
            self.out.write("shark_object_class __super;\n")
        if true then
            var i = 0
            while i<type.methods.size() do
                var method = type.methods.get(i)
                self.write_indent()
                if method.type==null then
                    self.out.write("void (*")
                else
                    self.write_type_name(method.type)
                    self.out.write(self.buf.get())
                    self.out.write(" (*")
                self.out.write(method.name)
                self.out.write(")(void *")
                if true then
                    var k = 0
                    while k<method.arg_types.size() do
                        self.out.write(", ")
                        self.write_type_name(method.arg_types.get(k))
                        self.out.write(self.buf.get())
                        k+=1
                self.out.write(");\n")
                i+=1
        self.dedent()
        self.out.write("};\nextern ")
        self.out.write(class_name)
        self.out.write(" shark_impl_")
        self.out.write(type.name)
        self.out.write(";\n")
        self.type_context=null
    function enter_type_impl(type)
        self.type_context=type
        self.impl_table=new strmap()
    function exit_type_impl()
        var type_count = 0
        var call_table = ""
        if true then
            var type = self.type_context
            while type!=null do
                if true then
                    var i = 0
                    while i<type.methods.size() do
                        self.buf.write(", ")
                        var method = type.methods.get(i)
                        self.buf.write("shark_lib_")
                        if self.impl_table.has(method.name) then
                            self.buf.write(self.type_context.name)
                        else
                            self.buf.write(type.name)
                        self.buf.write("_")
                        self.buf.write(method.name)
                        i+=1
                self.buf.write("}")
                self.buf.write(call_table)
                call_table=self.buf.get()
                type_count+=1
                type=type.parent
        if true then
            var i = 0
            while i<type_count do
                self.buf.write("{")
                i+=1
        self.buf.write("{ sizeof(struct _shark_type_")
        self.buf.write(self.type_context.name)
        self.buf.write("), ")
        if self.type_context.parent==null then
            self.buf.write("NULL }")
        else
            self.buf.write("&shark_impl_")
            self.buf.write(self.type_context.parent.name)
            self.buf.write(" }")
        self.buf.write(call_table)
        self.out.write("shark_class_")
        self.out.write(self.type_context.name)
        self.out.write(" shark_impl_")
        self.out.write(self.type_context.name)
        self.out.write(" = ")
        self.out.write(self.buf.get())
        self.out.write(";\n")
        self.type_context=null
    function var_decl(name, type)
        self.write_indent()
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    function global_var_decl(name, type, value)
        if not value then
            self.out.write("extern ")
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" shark_lib_")
        self.out.write(name)
        if value then
            self.out.write(" = ")
            self.out.write(self.exp)
        self.out.write(";\n")
    function declare_constructor(function_object)
        self.out.write("void shark_lib_")
        self.out.write(function_object.name)
        self.out.write("_")
        self.out.write(function_object.name)
        self.out.write("(void *self")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                self.out.write(", ")
                self.write_type_name(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(");\n")
        self.out.write("shark_type_")
        self.out.write(self.type_context.name)
        self.out.write(" shark_type_")
        self.out.write(self.type_context.name)
        self.out.write("_new(")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.write_type_name(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(");\n")
    function declare_method(function_object)
        if function_object.type!=null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        self.out.write(" shark_lib_")
        self.out.write(self.type_context.name)
        self.out.write("_")
        self.out.write(function_object.name)
        self.out.write("(void *self")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                self.out.write(", ")
                self.write_type_name(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(");\n")
    function declare_function(function_object)
        if function_object.type!=null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        self.out.write(" shark_lib_")
        self.out.write(function_object.name)
        self.out.write("(")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.write_type_name(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(");\n")
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        if self.type_context!=null and function_object.name==self.type_context.name then
            self.out.write("shark_type_")
            self.out.write(self.type_context.name)
            self.out.write(" shark_type_")
            self.out.write(self.type_context.name)
            self.out.write("_new(")
            if true then
                var i = 0
                while i<function_object.arg_names.size() do
                    if i!=0 then
                        self.out.write(", ")
                    self.write_type_name(function_object.arg_types.get(i))
                    self.out.write(self.buf.get())
                    self.out.write(" ")
                    self.out.write(function_object.arg_names.get(i))
                    i+=1
            self.out.write(") {")
            self.indent()
            self.write_indent()
            self.out.write("shark_type_")
            self.out.write(self.type_context.name)
            self.out.write(" self = shark_object_new(&shark_impl_")
            self.out.write(self.type_context.name)
            self.out.write(");\n")
            self.write_indent()
            self.out.write("shark_lib_")
            self.out.write(self.type_context.name)
            self.out.write("_")
            self.out.write(self.type_context.name)
            self.out.write("(self")
            if true then
                var i = 0
                while i<function_object.arg_names.size() do
                    self.out.write(", ")
                    self.out.write(function_object.arg_names.get(i))
                    i+=1
            self.out.write(");\n")
            self.write_indent()
            self.out.write("return self;\n")
            self.dedent()
            self.out.write("}\n")
        if function_object.type!=null then
            self.write_type_name(function_object.type)
            self.out.write(self.buf.get())
        else
            self.out.write("void")
        self.out.write(" shark_lib_")
        if self.type_context!=null then
            self.impl_table.set(function_object.name, 0)
            self.out.write(self.type_context.name)
            self.out.write("_")
        self.out.write(function_object.name)
        self.out.write("(")
        if self.type_context!=null then
            self.out.write("void *self")
            if function_object.arg_names.size()!=0 then
                self.out.write(", ")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.write_type_name(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(") {\n")
    function exit_function()
        self.out.write("}\n")
    function inline_stat(code)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    function enter_block()
        self.indent()
    function empty_block()
        shark_null_stat()
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function enter_else_if()
        self.write_indent()
        self.out.write("} else {\n")
    function else_if()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function else_clause()
        self.write_indent()
        self.out.write("} else {\n")
    function close_if()
        self.write_indent()
        self.out.write(self.buf.get())
        self.out.write("}\n")
    function close_else_if()
        self.buf.write("}")
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("while (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function exit_while()
        self.write_indent()
        self.out.write("}\n")
    function enter_for()
        self.init=false
        self.cond=null
        self.call_stack.push(self.step)
        self.step=null
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.init=true
        self.write_indent()
        self.out.write("do {\n")
        self.write_indent()
        self.write_type_name(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    function for_cond()
        self.cond=self.exp
    function for_step()
        self.step=self.exp
    function for_stat()
        self.write_indent()
        self.out.write("while (")
        if self.cond!=null then
            self.out.write(self.cond)
        else
            self.out.write("true")
        self.out.write(") {\n")
    function exit_for()
        if self.step!=null then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write(self.step)
            self.out.write(";\n")
        self.write_indent()
        if self.init then
            self.out.write("}} while (false);")
        else
            self.out.write("}\n")
        self.step=self.call_stack.pop()
    function break_stat()
        self.write_indent()
        self.out.write("break;\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue;\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write(";\n")
        else
            self.out.write("return;\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write(";\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if strop then
            if op=="!=" then
                self.buf.write("!")
            self.buf.write("shark_str_equals(")
            self.buf.write(self.exp_left)
            self.buf.write(", ")
            self.buf.write(self.exp)
            self.buf.write(")")
        else if objop then
            self.buf.write("((void *) ")
            self.buf.write(self.exp_left)
            self.buf.write(") ")
            self.buf.write(op)
            self.buf.write(" ((void *) ")
            self.buf.write(self.exp)
            self.buf.write(")")
        else
            if op=="and" then
                op="&&"
            if op=="or" then
                op="||"
            self.buf.write(self.exp_left)
            self.buf.write(op)
            self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="!"
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function inc_index(op)
        self.buf.write(self.exp_left)
        self.buf.write("->data[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("->data[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
        self.exit_assign()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("->data[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write("((shark_class_")
        self.buf.write(function_object.source_type.name)
        self.buf.write(" *) ((shark_object *) ")
        self.buf.write(self.exp_left)
        self.buf.write(")->type)->")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.buf.write(self.exp_left)
        if self.call_args.size()!=0 then
            self.buf.write(", ")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp_left)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write("((shark_type_")
        self.buf.write(field.source_type.name)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")->")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function inc_global(name, op)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.inc_local(self.buf.get(), op)
    function set_global(name, op)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.set_local(self.buf.get(), op)
    function get_global(name)
        self.buf.write("shark_lib_")
        self.buf.write(name)
        self.exp=self.buf.get()
    function self_exp()
        self.buf.write("((shark_type_")
        self.buf.write(self.type_context.name)
        self.buf.write(") self)")
        self.exp=self.buf.get()
    function sizeof_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write("->size)")
        self.exp=self.buf.get()
    function array_new(type)
        self.write_type(type, false)
        self.buf.write("_new(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write("shark_type_")
        self.buf.write(type.name)
        self.buf.write("_new(")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("shark_object_instanceof(")
        self.buf.write(self.exp)
        self.buf.write(", &shark_impl_")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        self.buf.write("((")
        self.write_type_name(type)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="NULL"
    function true_exp()
        self.exp="true"
    function false_exp()
        self.exp="false"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        var buf = new strbuf()
        buf.write("shark_string_")
        buf.write(itos(self.temp))
        self.temp+=1
        var name = buf.get()
        var size = 0
        var iter = new striter(value)
        while not iter.empty() do
            var c = iter.next()
            if c=='"' then
                continue
            else if c=='\\' then
                iter.next()
            size+=1
        self.out.write("static struct _shark_str ")
        self.out.write(name)
        self.out.write(" = SHARK_STR_LIT(")
        self.out.write(itos(size))
        self.out.write(", ")
        self.out.write(value)
        self.out.write(");\n")
        self.buf.write("&")
        self.buf.write(name)
        self.exp=self.buf.get()
class shark_backend_java(shark_backend)
    function init()
        self.shark_backend_java()
    function shark_backend_java()
        self.indent_level=0
        self.path=null
        self.out=null
        self.buf=null
        self.function_context=null
        self.init=false
        self.cond=false
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function enter_source(name, type)
        if not type then
            self.out.write("public static class ")
            self.out.write(name)
            self.out.write("\n{\n")
    function exit_source()
        self.out.write("}\n\n")
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.path=out
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.call_stack=new list()
    function close()
        self.out.close()
    function write_type(type)
        if instanceof(type, shark_basic_type) then
            if type==shark_basic_type_bool then
                self.buf.write("boolean")
            else if type==shark_basic_type_int then
                self.buf.write("long")
            else if type==shark_basic_type_float then
                self.buf.write("double")
            else if type==shark_basic_type_char then
                self.buf.write("char")
            else if type==shark_basic_type_str then
                self.buf.write("String")
            else
                self.buf.write("Object")
        else if instanceof(type, shark_custom_type) then
            self.buf.write(type.name)
        else
            var child = type.type
            self.write_type(child)
            self.buf.write("[]")
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        self.enter_source(type.name, true)
        self.out.write("public static class ")
        self.out.write(type.name)
        if type.parent!=null then
            self.out.write(" extends ")
            self.out.write(type.parent.name)
        self.out.write("\n{\n")
        self.indent()
        if true then
            var i = 0
            while i<type.fields.size() do
                var field = type.fields.get(i)
                self.write_indent()
                self.out.write("public ")
                self.write_type(field.type)
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(field.name)
                self.out.write(";\n")
                i+=1
    function exit_type_impl()
        self.dedent()
        self.exit_source()
    function var_decl(name, type)
        self.write_indent()
        self.write_type(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    function global_var_decl(name, type, value)
        if value then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write("public static ")
            self.write_type(type)
            self.out.write(self.buf.get())
            self.out.write(" ")
            self.out.write(name)
            self.out.write(" = ")
            self.out.write(self.exp)
            self.out.write(";\n")
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        if function_object.source_type!=null then
            self.write_indent()
            self.out.write("public ")
            if function_object.name==function_object.source_type.name then
                if function_object.arg_names.size()!=0 then
                    self.out.write(function_object.name)
                    self.out.write("() { }\n")
                    self.out.write("public ")
                self.out.write(function_object.name)
            else
                if function_object.type!=null then
                    self.write_type(function_object.type)
                    self.out.write(self.buf.get())
                else
                    self.out.write("void")
                self.out.write(" ")
                self.out.write(function_object.name)
        else
            self.indent()
            self.write_indent()
            self.out.write("public static ")
            if function_object.type!=null then
                self.write_type(function_object.type)
                self.out.write(self.buf.get())
            else
                self.out.write("void")
            self.out.write(" ")
            self.out.write(function_object.name)
            self.function_context=function_object
        self.out.write("(")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.write_type(function_object.arg_types.get(i))
                self.out.write(self.buf.get())
                self.out.write(" ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(") {\n")
        if function_object.source_type!=null and function_object.name==function_object.source_type.name then
            if function_object.source_type.constructor!=null then
                self.indent()
                self.write_indent()
                self.dedent()
                self.out.write("super();\n")
    function exit_function()
        self.write_indent()
        self.out.write("}\n")
        if self.function_context!=null then
            self.function_context=null
            self.dedent()
    function inline_stat(code)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    function enter_block()
        self.indent()
    function empty_block()
        shark_null_stat()
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function enter_else_if()
        shark_null_stat()
    function else_if()
        self.write_indent()
        self.out.write("} else if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function else_clause()
        self.write_indent()
        self.out.write("} else {\n")
    function close_if()
        self.write_indent()
        self.out.write("}\n")
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("while (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function exit_while()
        self.write_indent()
        self.out.write("}\n")
    function enter_for()
        self.write_indent()
        self.out.write("for (")
        self.init=false
        self.cond=false
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.write_type(type)
        self.out.write(self.buf.get())
        self.out.write(" ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";")
        self.init=true
    function for_cond()
        if self.init then
            self.out.write(" ")
        else
            self.out.write("; ")
        self.out.write(self.exp)
        self.out.write(";")
        self.init=true
        self.cond=true
    function for_step()
        if self.cond then
            self.out.write(" ")
        else
            if not self.init then
                self.out.write(";")
            self.out.write("; ")
            self.init=true
            self.cond=true
        self.out.write(self.exp)
    function for_stat()
        if not self.cond then
            if not self.init then
                self.out.write(";")
            self.out.write(";")
        self.out.write(") {\n")
    function exit_for()
        self.write_indent()
        self.out.write("}\n")
    function break_stat()
        self.write_indent()
        self.out.write("break;\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue;\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write(";\n")
        else
            self.out.write("return;\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write(";\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if not strop then
            if op=="and" then
                op="&&"
            if op=="or" then
                op="||"
            self.buf.write(self.exp_left)
            self.buf.write(op)
            self.buf.write(self.exp)
        else
            if op=="!=" then
                self.buf.write("!")
            self.buf.write(self.exp_left)
            self.buf.write(".equals(")
            self.buf.write(self.exp)
            self.buf.write(")")
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="!"
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.exp_left)
        self.push()
    function inc_index(op)
        self.buf.write(self.exp_left)
        self.buf.write("[(int)")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.exp_left=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp=self.buf.get()
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("[(int)")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_left=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp=self.buf.get()
        self.exit_assign()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("[(int)")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_left=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function inc_global(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_global(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_global(name)
        self.buf.write(name)
        self.exp=self.buf.get()
    function self_exp()
        self.exp="this"
    function sizeof_exp()
        self.buf.write(self.exp)
        self.buf.write(".length")
        self.exp=self.buf.get()
    function array_new(type)
        self.buf.write("new ")
        self.write_type(type.type)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write("new ")
        self.buf.write(type.name)
        self.buf.write("(")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(" instanceof ")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        self.buf.write("((")
        self.write_type(type)
        self.buf.write(") ")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="null"
    function true_exp()
        self.exp="true"
    function false_exp()
        self.exp="false"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        self.exp=value
class shark_backend_javascript(shark_backend)
    function init()
        self.shark_backend_javascript()
    function shark_backend_javascript()
        self.indent_level=0
        self.out=null
        self.buf=null
        self.type_context=null
        self.init=false
        self.cond=false
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.call_stack=new list()
    function close()
        shark_null_stat()
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        var parent = "Object"
        if type.parent!=null then
            parent=type.parent.name
        self.out.write(type.name)
        self.out.write(" = function () { };\n")
        self.out.write(type.name)
        self.out.write(".is_shark_class = true;\n")
        self.out.write(type.name)
        self.out.write(".prototype = new ")
        self.out.write(parent)
        self.out.write(" ();\n")
        self.out.write(type.name)
        self.out.write(".prototype.constructor = ")
        self.out.write(type.name)
        self.out.write(";\n")
        if type.parent!=null then
            self.out.write(type.name)
            self.out.write(".constructor = ")
            self.out.write(parent)
            self.out.write(".constructor;\n")
        else
            self.out.write(type.name)
            self.out.write(".constructor = function () { return this; };\n")
        self.type_context=type.name
    function exit_type_impl()
        self.type_context=null
    function var_decl(name, type)
        self.write_indent()
        self.out.write("var ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";\n")
    function global_var_decl(name, type, value)
        if value then
            self.out.write("var ")
            self.out.write(name)
            self.out.write(" = ")
            self.out.write(self.exp)
            self.out.write(";\n")
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        if function_object.source_type!=null then
            if function_object.name==function_object.source_type.name then
                self.out.write(function_object.name)
                self.out.write(".prototype.construct = function (")
                if true then
                    var i = 0
                    while i<function_object.arg_names.size() do
                        if i!=0 then
                            self.out.write(", ")
                        self.out.write(function_object.arg_names.get(i))
                        i+=1
                self.out.write(") { this.")
                self.out.write(function_object.name)
                self.out.write("(")
                if true then
                    var i = 0
                    while i<function_object.arg_names.size() do
                        if i!=0 then
                            self.out.write(", ")
                        self.out.write(function_object.arg_names.get(i))
                        i+=1
                self.out.write("); return this; };\n")
            self.out.write(self.type_context)
            self.out.write(".prototype.")
            self.out.write(function_object.name)
            self.out.write(" = function ")
        else
            self.out.write("function ")
            self.out.write(function_object.name)
        self.out.write("(")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(") {\n")
    function exit_function()
        self.out.write("}\n")
    function inline_stat(code)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    function enter_block()
        self.indent()
    function empty_block()
        shark_null_stat()
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function enter_else_if()
        shark_null_stat()
    function else_if()
        self.write_indent()
        self.out.write("} else if (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function else_clause()
        self.write_indent()
        self.out.write("} else {\n")
    function close_if()
        self.write_indent()
        self.out.write("}\n")
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("while (")
        self.out.write(self.exp)
        self.out.write(") {\n")
    function exit_while()
        self.write_indent()
        self.out.write("}\n")
    function enter_for()
        self.write_indent()
        self.out.write("for (")
        self.init=false
        self.cond=false
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.out.write("var ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write(";")
        self.init=true
    function for_cond()
        if self.init then
            self.out.write(" ")
        else
            self.out.write("; ")
        self.out.write(self.exp)
        self.out.write(";")
        self.init=true
        self.cond=true
    function for_step()
        if self.cond then
            self.out.write(" ")
        else
            if not self.init then
                self.out.write(";")
            self.out.write("; ")
            self.init=true
            self.cond=true
        self.out.write(self.exp)
    function for_stat()
        if not self.cond then
            if not self.init then
                self.out.write(";")
            self.out.write(";")
        self.out.write(") {\n")
    function exit_for()
        self.write_indent()
        self.out.write("}\n")
    function break_stat()
        self.write_indent()
        self.out.write("break;\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue;\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write(";\n")
        else
            self.out.write("return;\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write(";\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if op=="and" then
            op="&&"
        if op=="or" then
            op="||"
        self.buf.write(self.exp_left)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="!"
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function inc_index(op)
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
        self.exit_assign()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function inc_global(name, op)
        self.inc_local(name, op)
    function set_global(name, op)
        self.set_local(name, op)
    function get_global(name)
        self.exp=name
    function self_exp()
        self.exp="this"
    function sizeof_exp()
        self.buf.write(self.exp)
        self.buf.write(".length")
        self.exp=self.buf.get()
    function array_new(type)
        self.buf.write("new Array (")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write("(")
        self.buf.write(type.name)
        self.buf.write(".is_shark_class ? ")
        self.buf.write("new ")
        self.buf.write(type.name)
        self.buf.write("().construct(")
        self.write_args()
        self.buf.write(") : new ")
        self.buf.write(type.name)
        self.buf.write("(")
        self.write_args()
        self.exit_call()
        self.buf.write("))")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(" instanceof ")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        shark_null_stat()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="null"
    function true_exp()
        self.exp="true"
    function false_exp()
        self.exp="false"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        self.exp=value
class shark_backend_lua(shark_backend)
    function init()
        self.shark_backend_lua()
    function shark_backend_lua()
        self.indent_level=0
        self.out=null
        self.buf=null
        self.type=null
        self.cond=null
        self.step=null
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.call_stack=new list()
    function close()
        self.out.close()
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        self.out.write(type.name)
        self.out.write(" = __shark_create_class('")
        self.out.write(type.name)
        self.out.write("', ")
        if type.parent!=null then
            self.out.write(type.parent.name)
        else
            self.out.write("__shark_object")
        self.out.write(")\n")
        self.type=type
    function exit_type_impl()
        self.type=null
    function var_decl(name, type)
        self.write_indent()
        self.out.write("local ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function global_var_decl(name, type, value)
        if value then
            self.out.write(name)
            self.out.write(" = ")
            self.out.write(self.exp)
            self.out.write("\n")
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        if self.type==null then
            self.out.write("function ")
            self.out.write(function_object.name)
        else
            if self.type.name==function_object.name then
                self.out.write(function_object.source_type.name)
                self.out.write(".constructor = \"")
                self.out.write(function_object.name)
                self.out.write("\"\n")
            self.out.write(self.type.name)
            self.out.write(".")
            self.out.write(function_object.name)
            self.out.write(" = function ")
        self.out.write("(")
        if function_object.source_type!=null then
            self.out.write("self")
            if function_object.arg_names.size()!=0 then
                self.out.write(", ")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(")\n")
    function exit_function()
        self.out.write("end\n")
    function inline_stat(code)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    function enter_block()
        self.indent()
    function empty_block()
        shark_null_stat()
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if ")
        self.out.write(self.exp)
        self.out.write(" then\n")
    function enter_else_if()
        shark_null_stat()
    function else_if()
        self.write_indent()
        self.out.write("elseif ")
        self.out.write(self.exp)
        self.out.write(" then\n")
    function else_clause()
        self.write_indent()
        self.out.write("else\n")
    function close_if()
        self.write_indent()
        self.out.write("end\n")
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("repeat\n")
        self.indent()
        self.write_indent()
        self.out.write("local continue = false\n")
        self.write_indent()
        self.out.write("while ")
        self.out.write(self.exp)
        self.out.write(" do\n")
    function exit_while()
        self.write_indent()
        self.out.write("end\n")
        self.write_indent()
        self.out.write("if not continue then break else continue = false end\n")
        self.dedent()
        self.write_indent()
        self.out.write("until false\n")
    function enter_for()
        self.write_indent()
        self.out.write("repeat\n")
        self.indent()
        self.write_indent()
        self.out.write("local continue = false\n")
        self.cond=null
        self.call_stack.push(self.step)
        self.step=null
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.write_indent()
        self.out.write("local ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function for_cond()
        self.cond=self.exp
    function for_step()
        self.step=self.exp
    function for_stat()
        self.write_indent()
        self.out.write("while ")
        if self.cond!=null then
            self.out.write(self.cond)
        else
            self.out.write("true")
        self.out.write(" do\n")
    function exit_for()
        if self.step!=null then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write(self.step)
            self.out.write("\n")
        self.step=self.call_stack.pop()
        self.write_indent()
        self.out.write("end\n")
        self.write_indent()
        self.out.write("if not continue then break else continue = false end\n")
        self.dedent()
        self.write_indent()
        self.out.write("until false\n")
    function break_stat()
        self.write_indent()
        self.out.write("break\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue = true\n")
        self.write_indent()
        self.out.write("break\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write("\n")
        else
            self.out.write("return\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write("\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if op=="and" then
            op=" and "
        if op=="or" then
            op=" or "
        if op=="!=" then
            op="~="
        self.buf.write(self.exp_left)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="not "
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function inc_index(op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]=")
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write("1")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function get_assign_op(op)
        if op=="*=" then
            return "*"
        if op=="/=" then
            return "/"
        if op=="%=" then
            return "%"
        if op=="+=" then
            return "+"
        if op=="-=" then
            return "-"
        return ""
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        if op!="=" then
            op=self.get_assign_op(op)
            self.buf.write("=")
            self.buf.write(self.exp_base)
            self.buf.write("[")
            self.buf.write(self.exp_left)
            self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
        self.exit_assign()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write(self.exp_left)
        self.buf.write(":")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write("=")
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write("1")
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(field.name)
        if op!="=" then
            op=self.get_assign_op(op)
            self.buf.write("=")
            self.buf.write(self.exp_left)
            self.buf.write(".")
            self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(name)
        self.buf.write("=")
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write("1")
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        if op!="=" then
            op=self.get_assign_op(op)
            self.buf.write("=")
            self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function inc_global(name, op)
        self.inc_local(name, op)
    function set_global(name, op)
        self.set_local(name, op)
    function get_global(name)
        self.exp=name
    function self_exp()
        self.exp="self"
    function sizeof_exp()
        self.buf.write("#")
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function array_new(type)
        self.buf.write("__shark_array(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write("__shark_object_new(")
        self.buf.write(type.name)
        if self.call_args.size()!=0 then
            self.buf.write(", ")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("__shark_object_instanceof(")
        self.buf.write(self.exp)
        self.buf.write(", ")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        shark_null_stat()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="nil"
    function true_exp()
        self.exp="true"
    function false_exp()
        self.exp="false"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        self.exp=value
class shark_backend_python(shark_backend)
    function init()
        self.shark_backend_python()
    function shark_backend_python()
        self.indent_level=0
        self.out=null
        self.buf=null
        self.cond=null
        self.step=null
        self.globals=null
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.call_stack=new list()
    function close()
        self.out.close()
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        self.out.write("class ")
        self.out.write(type.name)
        if type.parent!=null then
            self.out.write("(")
            self.out.write(type.parent.name)
            self.out.write(")")
        self.out.write(":\n")
        self.indent()
        self.write_indent()
        self.out.write("def __init__(self, *args):\n")
        self.indent()
        self.write_indent()
        self.out.write("try: self.")
        self.out.write(type.name)
        self.out.write("(*args)\n")
        self.write_indent()
        self.out.write("except AttributeError: super(self).__init__(*args)\n")
        self.dedent()
    function exit_type_impl()
        self.dedent()
    function var_decl(name, type)
        self.write_indent()
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function global_var_decl(name, type, value)
        if value then
            self.out.write(name)
            self.out.write(" = ")
            self.out.write(self.exp)
            self.out.write("\n")
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        self.write_indent()
        self.out.write("def ")
        self.out.write(function_object.name)
        self.out.write("(")
        if function_object.source_type!=null then
            self.out.write("self")
            if function_object.arg_names.size()!=0 then
                self.out.write(", ")
        if function_object.arg_names.size()!=0 then
            self.out.write(function_object.arg_names.get(0))
        if true then
            var i = 1
            while i<function_object.arg_names.size() do
                self.out.write(", ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write("):\n")
        self.globals=new strmap()
    function exit_function()
        self.globals=null
    function inline_stat(code)
        self.write_indent()
        self.out.write(code)
        self.out.write("\n")
    function enter_block()
        self.indent()
    function empty_block()
        self.write_indent()
        self.out.write("pass\n")
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if ")
        self.out.write(self.exp)
        self.out.write(":\n")
    function enter_else_if()
        shark_null_stat()
    function else_if()
        self.write_indent()
        self.out.write("elif ")
        self.out.write(self.exp)
        self.out.write(":\n")
    function else_clause()
        self.write_indent()
        self.out.write("else:\n")
    function close_if()
        shark_null_stat()
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("while ")
        self.out.write(self.exp)
        self.out.write(":\n")
    function exit_while()
        shark_null_stat()
    function enter_for()
        self.cond=null
        self.call_stack.push(self.step)
        self.step=null
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.write_indent()
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function for_cond()
        self.cond=self.exp
    function for_step()
        self.step=self.exp
    function for_stat()
        self.write_indent()
        self.out.write("while ")
        if self.cond!=null then
            self.out.write(self.cond)
        else
            self.out.write("True")
        self.out.write(":\n")
    function exit_for()
        if self.step!=null then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write(self.step)
            self.out.write("\n")
        self.step=self.call_stack.pop()
    function break_stat()
        self.write_indent()
        self.out.write("break\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write("\n")
        else
            self.out.write("return\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write("\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if op=="and" then
            op=" and "
        if op=="or" then
            op=" or "
        self.buf.write(self.exp_left)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="not "
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function inc_index(op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write("=1")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exit_assign()
        self.exp=self.buf.get()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write("=1")
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write("=1")
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function declare_global(name)
        if not self.globals.has(name) then
            self.globals.set(name, 0)
            self.write_indent()
            self.out.write("global ")
            self.out.write(name)
            self.out.write("\n")
    function inc_global(name, op)
        self.declare_global(name)
        self.inc_local(name, op)
    function set_global(name, op)
        self.declare_global(name)
        self.set_local(name, op)
    function get_global(name)
        self.exp=name
    function self_exp()
        self.exp="self"
    function sizeof_exp()
        self.buf.write("len(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function array_new(type)
        self.buf.write("([ None ] * ")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write(type.name)
        self.buf.write("(")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("isinstance(")
        self.buf.write(self.exp)
        self.buf.write(", ")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        shark_null_stat()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="None"
    function true_exp()
        self.exp="True"
    function false_exp()
        self.exp="False"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        self.exp=value
class shark_backend_shark(shark_backend)
    function init()
        self.shark_backend_shark()
    function shark_backend_shark()
        self.indent_level=0
        self.out=null
        self.buf=null
        self.cond=null
        self.step=null
        self.exp=null
        self.exp_left=null
        self.exp_base=null
        self.call_stack=null
        self.call_args=null
    function indent()
        self.indent_level+=1
    function dedent()
        self.indent_level-=1
    function write_indent()
        if true then
            var i = 0
            while i<self.indent_level do
                self.out.write("    ")
                i+=1
    function begin(out)
        self.buf=new strbuf()
        self.out=open(out, 'w')
        if self.out==null then
            write("can't open output file '")
            write(out)
            write("' for writing, compilation aborted.")
            exit(EXIT_FAILURE)
        self.out.write("function __shark_array_new(size)\n")
        self.out.write("    var data = [ ]\n")
        self.out.write("    for _ in range(size) do\n")
        self.out.write("        data << null\n")
        self.out.write("    return data\n")
        self.call_stack=new list()
    function close()
        self.out.close()
    function enter_type_decl(type)
        shark_null_stat()
    function exit_type_decl()
        shark_null_stat()
    function enter_type_impl(type)
        self.out.write("class ")
        self.out.write(type.name)
        if type.parent!=null then
            self.out.write("(")
            self.out.write(type.parent.name)
            self.out.write(")")
        self.out.write("\n")
        self.indent()
    function exit_type_impl()
        self.dedent()
    function var_decl(name, type)
        self.write_indent()
        self.out.write("var ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function global_var_decl(name, type, value)
        if value then
            self.out.write("var ")
            self.out.write(name)
            self.out.write(" = ")
            self.out.write(self.exp)
            self.out.write("\n")
    function declare_constructor(function_object)
        shark_null_stat()
    function declare_method(function_object)
        shark_null_stat()
    function declare_function(function_object)
        shark_null_stat()
    function close_function_declaration()
        shark_null_stat()
    function enter_function(function_object)
        if (function_object.source_type!=null and function_object.name==function_object.source_type.name) then
            self.write_indent()
            self.out.write("function init(")
            if true then
                var i = 0
                while i<function_object.arg_names.size() do
                    if i!=0 then
                        self.out.write(", ")
                    self.out.write(function_object.arg_names.get(i))
                    i+=1
            self.out.write(")\n        self.")
            self.out.write(function_object.name)
            self.out.write("(")
            if true then
                var i = 0
                while i<function_object.arg_names.size() do
                    if i!=0 then
                        self.out.write(", ")
                    self.out.write(function_object.arg_names.get(i))
                    i+=1
            self.out.write(")\n")
        self.write_indent()
        self.out.write("function ")
        self.out.write(function_object.name)
        self.out.write("(")
        if true then
            var i = 0
            while i<function_object.arg_names.size() do
                if i!=0 then
                    self.out.write(", ")
                self.out.write(function_object.arg_names.get(i))
                i+=1
        self.out.write(")\n")
    function exit_function()
        shark_null_stat()
    function enter_block()
        self.indent()
    function empty_block()
        self.write_indent()
        self.out.write("pass\n")
    function exit_block()
        self.dedent()
    function if_stat()
        self.write_indent()
        self.out.write("if ")
        self.out.write(self.exp)
        self.out.write(" then\n")
    function enter_else_if()
        shark_null_stat()
    function else_if()
        self.write_indent()
        self.out.write("else if ")
        self.out.write(self.exp)
        self.out.write(" then\n")
    function else_clause()
        self.write_indent()
        self.out.write("else\n")
    function close_if()
        shark_null_stat()
    function close_else_if()
        shark_null_stat()
    function enter_while()
        shark_null_stat()
    function while_stat()
        self.write_indent()
        self.out.write("while ")
        self.out.write(self.exp)
        self.out.write(" do\n")
    function exit_while()
        shark_null_stat()
    function enter_for()
        self.cond=null
        self.call_stack.push(self.step)
        self.step=null
        self.write_indent()
        self.out.write("if true then\n")
        self.indent()
    function push()
        self.exp_base=self.exp_left
        self.exp_left=self.exp
    function for_init(name, type)
        self.write_indent()
        self.out.write("var ")
        self.out.write(name)
        self.out.write(" = ")
        self.out.write(self.exp)
        self.out.write("\n")
    function for_cond()
        self.cond=self.exp
    function for_step()
        self.step=self.exp
    function for_stat()
        self.write_indent()
        self.out.write("while ")
        if self.cond!=null then
            self.out.write(self.cond)
        else
            self.out.write("true")
        self.out.write(" do\n")
    function exit_for()
        if self.step!=null then
            self.indent()
            self.write_indent()
            self.dedent()
            self.out.write(self.step)
            self.out.write("\n")
        self.step=self.call_stack.pop()
        self.dedent()
    function break_stat()
        self.write_indent()
        self.out.write("break\n")
    function continue_stat()
        self.write_indent()
        self.out.write("continue\n")
    function return_stat(value)
        self.write_indent()
        if value then
            self.out.write("return ")
            self.out.write(self.exp)
            self.out.write("\n")
        else
            self.out.write("return\n")
    function assign_stat()
        self.write_indent()
        self.out.write(self.exp)
        self.out.write("\n")
    function enter_assign()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.exp_base)
        self.push()
    function exit_assign()
        self.exp_base=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function enter_binop()
        self.call_stack.push(self.exp_left)
        self.push()
    function binary_op(op, strop, objop)
        if op=="and" then
            op=" and "
        if op=="or" then
            op=" or "
        self.buf.write(self.exp_left)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exp_left=self.call_stack.pop()
    function unary_op(op)
        if op=="not" then
            op="not "
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
    function enter_index()
        self.call_stack.push(self.exp_left)
        self.push()
    function inc_index(op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write("=1")
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function set_index(op)
        self.buf.write(self.exp_base)
        self.buf.write("[")
        self.buf.write(self.exp_left)
        self.buf.write("]")
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
        self.exit_assign()
    function get_index()
        self.buf.write(self.exp_left)
        self.buf.write("[")
        self.buf.write(self.exp)
        self.buf.write("]")
        self.exp_left=self.call_stack.pop()
        self.exp=self.buf.get()
    function call_method(function_object)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(function_object.name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function write_args()
        if self.call_args.size()!=0 then
            self.buf.write(self.call_args.get(0))
            if true then
                var i = 1
                while i<self.call_args.size() do
                    self.buf.write(", ")
                    self.buf.write(self.call_args.get(i))
                    i+=1
    function enter_call()
        self.call_stack.push(self.exp_left)
        self.call_stack.push(self.call_args)
        self.push()
        self.call_args=new list()
    function exit_call()
        self.call_args=self.call_stack.pop()
        self.exp_left=self.call_stack.pop()
    function push_arg()
        self.call_args.push(self.exp)
    function inc_field(field, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write("=1")
        self.exp=self.buf.get()
    function set_field(field, op)
        self.buf.write(self.exp_left)
        self.buf.write(".")
        self.buf.write(field.name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_field(field)
        self.buf.write(self.exp)
        self.buf.write(".")
        self.buf.write(field.name)
        self.exp=self.buf.get()
    function inc_local(name, op)
        if op=="++" then
            op="+"
        if op=="--" then
            op="-"
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write("=1")
        self.exp=self.buf.get()
    function set_local(name, op)
        self.buf.write(name)
        self.buf.write(op)
        self.buf.write(self.exp)
        self.exp=self.buf.get()
        self.exit_assign()
    function get_local(name)
        self.exp=name
    function call_function(name)
        self.buf.write(name)
        self.buf.write("(")
        self.write_args()
        self.buf.write(")")
        self.exit_call()
        self.exp=self.buf.get()
    function inc_global(name, op)
        self.inc_local(name, op)
    function set_global(name, op)
        self.set_local(name, op)
    function get_global(name)
        self.exp=name
    function self_exp()
        self.exp="self"
    function sizeof_exp()
        self.buf.write("sizeof(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function array_new(type)
        self.buf.write("__shark_array_new(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function object_new(type)
        self.buf.write("new ")
        self.buf.write(type.name)
        self.buf.write("(")
        self.write_args()
        self.exit_call()
        self.buf.write(")")
        self.exp=self.buf.get()
    function instanceof_exp(type)
        self.buf.write("instanceof(")
        self.buf.write(self.exp)
        self.buf.write(", ")
        self.buf.write(type.name)
        self.buf.write(")")
        self.exp=self.buf.get()
    function cast_exp(type)
        shark_null_stat()
    function nested_exp()
        self.buf.write("(")
        self.buf.write(self.exp)
        self.buf.write(")")
        self.exp=self.buf.get()
    function null_exp()
        self.exp="null"
    function true_exp()
        self.exp="true"
    function false_exp()
        self.exp="false"
    function int_exp(value)
        self.exp=value
    function float_exp(value)
        self.exp=value
    function char_exp(value)
        self.exp=value
    function str_exp(value)
        self.exp=value
var shark_compiler_op_priority = null
function shark_compiler_init()
    shark_compiler_op_priority=new strmap()
    shark_compiler_op_priority.set("or", 1)
    shark_compiler_op_priority.set("and", 2)
    shark_compiler_op_priority.set("&", 3)
    shark_compiler_op_priority.set("|", 3)
    shark_compiler_op_priority.set("^", 3)
    shark_compiler_op_priority.set("<<", 4)
    shark_compiler_op_priority.set(">>", 4)
    shark_compiler_op_priority.set("==", 5)
    shark_compiler_op_priority.set("!=", 5)
    shark_compiler_op_priority.set("<", 6)
    shark_compiler_op_priority.set("<=", 6)
    shark_compiler_op_priority.set(">", 6)
    shark_compiler_op_priority.set(">=", 6)
    shark_compiler_op_priority.set("+", 7)
    shark_compiler_op_priority.set("-", 7)
    shark_compiler_op_priority.set("*", 8)
    shark_compiler_op_priority.set("/", 8)
    shark_compiler_op_priority.set("%", 8)
    shark_basic_type_void=new shark_type()
    shark_basic_type_bool=new shark_basic_type("bool")
    shark_basic_type_int=new shark_basic_type("int")
    shark_basic_type_float=new shark_basic_type("float")
    shark_basic_type_char=new shark_basic_type("char")
    shark_basic_type_str=new shark_basic_type("str")
    shark_basic_type_any=new shark_basic_any_type()
    shark_compiler_basic_types=new shark_namespace(null)
    shark_compiler_basic_types.add("bool", shark_basic_type_bool)
    shark_compiler_basic_types.add("int", shark_basic_type_int)
    shark_compiler_basic_types.add("float", shark_basic_type_float)
    shark_compiler_basic_types.add("char", shark_basic_type_char)
    shark_compiler_basic_types.add("str", shark_basic_type_str)
    shark_compiler_basic_types.add("object", shark_basic_type_any)
class shark_compiler
    function init()
        self.shark_compiler()
    function shark_compiler()
        shark_compiler_init()
        self.import_record=new strmap()
        self.namespace=new shark_namespace(null)
        self.source_context=null
        self.lexer=null
        self.token=null
        self.errbuf=null
        self.callee=null
    function compile(filename, include, backend, out)
        self.include=include
        self.backend=backend
        self.backend.begin(out)
        var source = open(filename, 'r')
        if source==null then
            self.write_error("can't open input file '")
            self.write_error(filename)
            self.write_error("' for reading, compilation aborted.")
            self.error()
        self.import_record=new strmap()
        self.namespace=new shark_namespace(null)
        self.source_context=filename
        self.lexer=new shark_lexer(filename, source)
        self.token=self.lexer.scan()
        self.type_context=null
        self.function_context=null
        self.context=null
        self.in_type=false
        self.in_impl=false
        self.in_function=false
        self.in_loop=false
        self.assign_target=false
        self.else_if=false
        self.source_file()
        self.backend.close()
    function write_error(data)
        if self.errbuf==null then
            self.errbuf=new strbuf()
            self.errbuf.write("[error] ")
            if self.source_context!=null then
                self.errbuf.write("File '")
                self.errbuf.write(self.source_context)
                self.errbuf.write("', line ")
                self.errbuf.write(itos(self.token.lineno))
                self.errbuf.write(": ")
        self.errbuf.write(data)
    function error()
        write(self.errbuf.get())
        exit(EXIT_FAILURE)
    function next()
        var value = self.token.value
        self.token=self.lexer.scan()
        return value
    function match(value)
        if self.token.value==value then
            self.next()
            return true
        else
            return false
    function consume(type)
        if self.token.type!=type then
            self.write_error("invalid token type, expected '")
            self.write_error(type)
            self.write_error("' but got '")
            self.write_error(self.token.type)
            self.write_error("'.")
            self.error()
        return self.next()
    function expect(value)
        if not self.match(value) then
            self.write_error("invalid token, expected '")
            self.write_error(value)
            self.write_error("' but got '")
            self.write_error(self.token.value)
            self.write_error("'.")
            self.error()
    function eol()
        if self.match(";") then
            self.seol()
        else if self.token.type=="newline" then
            self.next()
        else
            self.write_error("expected EOL but got '")
            self.write_error(self.token.type)
            self.write_error("' token.")
            self.error()
    function seol()
        if self.token.type=="newline" then
            self.next()
    function match_indent()
        if self.token.type=="indent" then
            self.next()
            return true
        else
            return false
    function match_dedent()
        if self.token.type=="dedent" then
            self.next()
            return true
        else
            return false
    function indent()
        if not self.match_indent() then
            self.write_error("expected an indented block.")
            self.error()
    function dedent(lineno)
        if not self.match_dedent() then
            self.write_error("expected the end of the block (started at line ")
            self.write_error(itos(lineno))
            self.write_error(").")
            self.error()
    function at_end()
        return self.token.type=="EOF"
    function source_file()
        while not self.at_end() do
            if not self.decl() then
                self.write_error("expected global declaration.")
                self.error()
    function decl()
        return (self.import_decl() or self.typedef_decl() or self.var_decl() or self.function_decl() or self.inline_stat())
    function import_decl()
        if self.match("import") then
            var import_path = self.import_path()
            self.eol()
            if self.import_record.has(import_path) then
                return true
            self.import_record.set(import_path, 0)
            var filename = null
            var source = null
            if true then
                var i = 0
                while i<self.include.size() do
                    filename=shark_path_join(self.include.get(i), import_path)
                    source=open(filename, 'r')
                    if source!=null then
                        break
                    i+=1
            if source==null then
                self.write_error("can't resolve import '")
                self.write_error(import_path)
                self.write_error("'.")
                self.error()
            var prev_source_context = self.source_context
            var prev_lexer = self.lexer
            var prev_token = self.token
            self.source_context=filename
            self.lexer=new shark_lexer(filename, source)
            self.token=self.lexer.scan()
            self.source_file()
            self.source_context=prev_source_context
            self.lexer=prev_lexer
            self.token=prev_token
            return true
        else
            return false
    function import_path()
        var path = self.consume("str")
        var iter = new striter(path)
        var buf = new strbuf()
        var size = 0
        iter.next()
        while not iter.empty() do
            var c = iter.next()
            if c=='"' then
                break
            buf.put(c)
            size+=1
        if size==0 then
            self.write_error("empty filename.")
            self.error()
        return buf.get()
    function basic_type()
        if shark_compiler_basic_types.has(self.token.value) then
            return shark_compiler_basic_types.get(self.next())
        else
            return null
    function custom_type()
        if self.token.type!="name" then
            self.write_error("expected a custom type.")
            self.error()
        var type_name = self.next()
        if not self.namespace.has(type_name) then
            self.write_error("type '")
            self.write_error(type_name)
            self.write_error("' is not defined.")
            self.error()
        var type = self.namespace.get(type_name)
        if not instanceof(type, shark_custom_type) then
            self.write_error("name '")
            self.write_error(type_name)
            self.write_error("' is not a custom type.")
            self.error()
        return type
    function type()
        if self.match("[") then
            self.expect("]")
            return new shark_array_type(self.type())
        else
            var type = self.basic_type()
            if type==null then
                return self.custom_type()
            return type
    function typedef_decl()
        if self.match("class") then
            var name = self.consume("name")
            var parent = null
            var type = null
            self.in_type=true
            if self.match("(") then
                self.in_impl=false
                if not self.match("object") then
                    parent=self.custom_type()
                self.expect(")")
                if self.namespace.has(name) then
                    self.write_error("name '")
                    self.write_error(name)
                    self.write_error("' is already defined.")
                    self.error()
                type=new shark_custom_type(name, parent)
                self.namespace.add(name, type)
                self.backend.enter_type_decl(type)
            else
                self.in_impl=true
                if not self.namespace.has(name) then
                    self.write_error("type '")
                    self.write_error(name)
                    self.write_error("' is not defined.")
                    self.error()
                var proto = self.namespace.get(name)
                if not instanceof(proto, shark_custom_type) then
                    self.write_error("name '")
                    self.write_error(name)
                    self.write_error("' is not a custom type.")
                    self.error()
                type=proto
                if type.implemented then
                    self.write_error("type '")
                    self.write_error(type.name)
                    self.write_error(" is already implemented.")
                    self.error()
                self.backend.enter_type_impl(type)
            self.eol()
            self.indent()
            self.type_context=type
            while not self.match_dedent() do
                var node = false
                if not self.in_impl then
                    node=self.var_decl() or self.function_decl()
                else
                    node=self.function_decl()
                if not node then
                    self.write_error("expected a declaration in typedef body.")
                    self.error()
            if self.in_impl then
                type.implemented=true
                self.backend.exit_type_impl()
            else
                self.backend.exit_type_decl()
            self.type_context=null
            self.in_type=false
            self.in_impl=false
            return true
        else
            return false
    function var_decl()
        if self.match("var") then
            var name = self.consume("name")
            self.expect(":")
            var type = self.type()
            var value = false
            if self.match("=") then
                if self.in_function then
                    value=true
                    self.exp()
                else if self.in_type then
                    self.write_error("type field can't have an static initializer.")
                    self.error()
                else
                    value=self.literal()
                    if not value then
                        self.write_error("expected a literal expression.")
                        self.error()
            else if self.in_function then
                self.write_error("local variable declaration should have an initializer.")
                self.error()
            if self.in_function then
                if self.context.has(name) then
                    self.write_error("name '")
                    self.write_error(name)
                    self.write_error(" is defined twice.")
                    self.error()
                self.context.add(name, new shark_variable(name, type))
                if not type.get_cast(self.exp_type) then
                    self.write_error("invalid initializer type in variable declaration.")
                    self.error()
                self.backend.var_decl(name, type)
            else if self.in_type then
                if self.type_context.namespace.has(name) then
                    self.write_error("name '")
                    self.write_error(name)
                    self.write_error("' is already defined.")
                    self.error()
                var variable = new shark_variable(name, type)
                self.type_context.namespace.add(name, variable)
                self.type_context.fields.push(variable)
                variable.source_type=self.type_context
            else if value then
                if self.namespace.has(name) then
                    var proto = self.namespace.get(name)
                    if not instanceof(proto, shark_variable) then
                        self.write_error("name '")
                        self.write_error(name)
                        self.write_error("' is already defined.")
                        self.error()
                    else if not proto.type.equals(type) then
                        self.write_error("variable definition doesn't match declaration.")
                else
                    self.namespace.add(name, new shark_variable(name, type))
                if not type.get_cast(self.exp_type) then
                    self.write_error("invalid initializer type in variable declaration.")
                    self.error()
                self.backend.global_var_decl(name, type, true)
            else if self.namespace.has(name) then
                self.write_error("name '")
                self.write_error(name)
                self.write_error("' is already defined.")
                self.error()
            else
                self.namespace.add(name, new shark_variable(name, type))
                self.backend.global_var_decl(name, type, false)
            self.eol()
            return true
        else
            return false
    function function_decl()
        if self.match("function") then
            var name = self.consume("name")
            self.args()
            var type = null
            if self.match("->") then
                type=self.type()
            self.eol()
            var proto = null
            if self.in_type then
                if self.type_context.namespace.has(name) then
                    proto=self.type_context.namespace.get(name)
            else if not self.in_type and self.namespace.has(name) then
                proto=self.namespace.get(name)
            var func = null
            if proto==null then
                func=new shark_function(name, self.type_context, self.arg_names, self.arg_types, type)
                if self.in_type then
                    if self.in_impl then
                        self.write_error("method '")
                        self.write_error(name)
                        self.write_error("' was not declared in type header.")
                        self.error()
                    self.type_context.namespace.add(name, func)
                    self.type_context.methods.push(func)
                    if name==self.type_context.name then
                        if type!=null then
                            self.write_error("type constructor should not return a value.")
                            self.error()
                        self.type_context.constructor=func
                        self.backend.declare_constructor(func)
                    else
                        self.backend.declare_method(func)
                else
                    self.namespace.add(name, func)
                    self.backend.declare_function(func)
            else if not instanceof(proto, shark_function) then
                self.write_error("name '")
                self.write_error(name)
                self.write_error("' is already defined.")
                self.error()
            else if proto.implemented and not self.in_type then
                self.write_error("function '")
                self.write_error(name)
                self.write_error("' is already implemented.")
                self.error()
            else
                func=proto
                if not self.function_equals(self.arg_types, func.arg_types, type, func.type) then
                    self.write_error("function signature doesn't match prototype.")
                    self.error()
                else
                    func.arg_names=self.arg_names
            self.function_context=func
            self.in_function=true
            if self.token.type!="indent" then
                if self.in_impl then
                    self.write_error("expected a function body in typedef implementation.")
                    self.error()
                self.backend.close_function_declaration()
            else
                if self.in_type and not self.in_impl then
                    self.write_error("unexpected function body in typedef declaration.")
                    self.error()
                self.backend.enter_function(func)
                var context = new shark_namespace(null)
                if true then
                    var i = 0
                    while i<self.arg_names.size() do
                        context.add(self.arg_names.get(i), new shark_variable(self.arg_names.get(i), self.arg_types.get(i)))
                        i+=1
                self.do_block(context)
                self.backend.exit_function()
            self.function_context=null
            self.in_function=false
            return true
        else
            return false
    function args()
        self.arg_names=new list()
        self.arg_types=new list()
        self.expect("(")
        if not self.match(")") then
            self.arg_names.push(self.consume("name"))
            self.expect(":")
            self.arg_types.push(self.type())
            while self.match(",") do
                self.arg_names.push(self.consume("name"))
                self.expect(":")
                self.arg_types.push(self.type())
            self.expect(")")
    function function_equals(xargs, yargs, xtype, ytype)
        if xargs.size()!=yargs.size() then
            return false
        if true then
            var i = 0
            while i<xargs.size() do
                if not xargs.get(i).equals(yargs.get(i)) then
                    return false
                i+=1
        return xtype==ytype or (xtype!=null and xtype.equals(ytype))
    function inline_stat()
        if self.match("inline") then
            self.backend.inline_stat(self.consume("str"))
            self.eol()
            return true
        else
            return false
    function block()
        self.do_block(new shark_namespace(self.context))
    function do_block(context)
        self.seol()
        self.indent()
        self.context=context
        self.backend.enter_block()
        while not self.match_dedent() do
            if not (self.var_decl() or self.statement() or self.inline_stat()) then
                self.write_error("expected declaration or statement.")
                self.error()
        self.context=self.context.parent
        self.backend.exit_block()
    function statement()
        if self.match("if") then
            if self.else_if then
                self.backend.enter_else_if()
            self.exp()
            self.expect("then")
            var else_if = false
            if self.else_if then
                else_if=true
                self.backend.else_if()
                self.else_if=false
            else
                self.backend.if_stat()
            if self.exp_type!=shark_basic_type_bool then
                self.write_error("expected a boolean value as predicate.")
                self.error()
            self.block()
            if self.match("else") then
                if self.token.value=="if" then
                    self.else_if=true
                    self.statement()
                else
                    self.backend.else_clause()
                    self.block()
            if else_if then
                self.backend.close_else_if()
            else
                self.backend.close_if()
            return true
        else if self.match("while") then
            self.backend.enter_while()
            self.exp()
            self.expect("do")
            if self.exp_type!=shark_basic_type_bool then
                self.write_error("expected a boolean value as predicate.")
                self.error()
            self.backend.while_stat()
            var prev_in_loop = self.in_loop
            self.in_loop=true
            self.block()
            self.in_loop=prev_in_loop
            self.backend.exit_while()
            return true
        else if self.match("for") then
            self.backend.enter_for()
            var context = new shark_namespace(self.context)
            var name = null
            var type = null
            if not self.match(",") then
                name=self.consume("name")
                self.expect(":")
                type=self.type()
                self.expect("=")
                self.exp()
                if not type.get_cast(self.exp_type) then
                    self.write_error("invalid initializer.")
                    self.error()
                self.expect(",")
                context.add(name, new shark_variable(name, type))
                self.backend.for_init(name, type)
            self.context=context
            if not self.match(",") then
                self.exp()
                if self.exp_type!=shark_basic_type_bool then
                    self.write_error("expected a boolean value as predicate.")
                    self.error()
                self.expect(",")
                self.backend.for_cond()
            if self.token.value!="do" then
                self.assign()
                self.backend.for_step()
            self.backend.for_stat()
            self.expect("do")
            var prev_in_loop = self.in_loop
            self.in_loop=true
            self.do_block(context)
            self.in_loop=prev_in_loop
            self.backend.exit_for()
            return true
        else if self.match("break") then
            if not self.in_loop then
                self.write_error("break statement outside loop.")
                self.error()
            self.eol()
            self.backend.break_stat()
            return true
        else if self.match("continue") then
            if not self.in_loop then
                self.write_error("continue statement outside loop.")
                self.error()
            self.eol()
            self.backend.continue_stat()
            return true
        else if self.match("return") then
            if self.token.value!=";" and self.token.type!="newline" then
                self.exp()
                if self.function_context.type==null then
                    self.write_error("unexpected return value in void function.")
                    self.error()
                else if not self.function_context.type.get_cast(self.exp_type) then
                    self.write_error("invalid return value.")
                    self.error()
                self.eol()
                self.backend.return_stat(true)
            else if self.function_context.type!=null then
                self.write_error("missing return value in void function.")
                self.error()
            else
                self.eol()
                self.backend.return_stat(false)
            return true
        else
            return self.assign_stat()
    function assign_stat()
        if not self.assign() then
            return false
        self.eol()
        self.backend.assign_stat()
        return true
    function assign()
        self.assign_target=true
        var target = self.optional_exp()
        self.assign_target=false
        return target
    function match_inc()
        if self.assign_target then
            if self.match("++") then
                if self.exp_type!=shark_basic_type_int then
                    self.write_error("invalid increment target (not an integer).")
                    self.error()
                self.assign_op="++"
                return true
            else if self.match("--") then
                if self.exp_type!=shark_basic_type_int then
                    self.write_error("invalid increment target (not an integer).")
                    self.error()
                self.assign_op="--"
                return true
            else
                return false
        else
            return false
    function match_assign()
        if self.assign_target and self.token.type=="assign" then
            self.backend.enter_assign()
            var type = self.exp_type
            var op = self.next()
            self.exp()
            if not type.get_cast(self.exp_type) then
                self.write_error("invalid assignment.")
                self.error()
            else if op!="=" and type!=shark_basic_type_int and type!=shark_basic_type_float then
                self.write_error("invalid type in augmented assignment.")
                self.error()
            self.assign_op=op
            return true
        else
            return false
    function binary_op(priority)
        var exp = self.unary_op()
        while exp do
            var type = self.exp_type
            var op = self.token.value
            if (shark_compiler_op_priority.has(op) and shark_compiler_op_priority.get(op)>priority) then
                var strop = false
                var objop = false
                self.next()
                self.backend.enter_binop()
                self.binary_op(shark_compiler_op_priority.get(op))
                if op=="and" or op=="or" then
                    if type!=shark_basic_type_bool or self.exp_type!=shark_basic_type_bool then
                        self.write_error("expected a boolean value in short circuit operator.")
                        self.error()
                    self.exp_type=shark_basic_type_bool
                else if op=="==" or op=="!=" then
                    if not type.get_cast(self.exp_type) and not self.exp_type.get_cast(type) then
                        self.write_error("invalid type in operation.")
                        self.error()
                    if type==shark_basic_type_str and self.exp_type==shark_basic_type_str then
                        strop=true
                    else if instanceof(self.exp_type, shark_custom_type) or instanceof(type, shark_custom_type) then
                        objop=true
                    self.exp_type=shark_basic_type_bool
                else if type!=self.exp_type then
                    self.write_error("invalid type in operation.")
                    self.error()
                else if type!=shark_basic_type_int and type!=shark_basic_type_float then
                    self.write_error("invalid type in operation.")
                    self.error()
                else if ((op=="%" or op=="<<" or op==">>" or op=="&" or op=="|" or op=="^") and type!=shark_basic_type_int) then
                    self.write_error("invalid type in operation.")
                    self.error()
                else if op=="<" or op=="<=" or op==">" or op==">=" then
                    self.exp_type=shark_basic_type_bool
                self.backend.binary_op(op, strop, objop)
            else
                break
        return exp
    function unary_op()
        var op = self.token.value
        if op=="not" or op=="-" or op=="~" then
            self.next()
            if not self.unary_op() then
                self.write_error("expected expression after '")
                self.write_error(op)
                self.write_error("'.")
                self.error()
            else if op=="not" then
                if self.exp_type!=shark_basic_type_bool then
                    self.write_error("expected a boolean value in logic negation.")
                    self.error()
            else if op=="~" then
                if self.exp_type!=shark_basic_type_int then
                    self.write_error("expected integer value in binary negation.")
                    self.error()
            else if self.exp_type!=shark_basic_type_int and self.exp_type!=shark_basic_type_float then
                self.write_error("invalid type in numeric negation.")
                self.error()
            self.backend.unary_op(op)
            return true
        else
            return self.post_op()
    function post_op()
        var exp = self.primary_exp()
        while exp do
            if self.match("[") then
                self.backend.enter_index()
                if not instanceof(self.exp_type, shark_array_type) then
                    self.write_error("expected an array as indexing target.")
                    self.error()
                var type = self.exp_type
                self.exp()
                if self.exp_type!=shark_basic_type_int then
                    self.write_error("array index should be an integer.")
                    self.error()
                self.expect("]")
                self.exp_type=type.type
                if self.match_inc() then
                    self.backend.inc_index(self.assign_op)
                else if self.match_assign() then
                    self.backend.set_index(self.assign_op)
                else
                    self.backend.get_index()
            else if self.match(".") then
                var name = self.consume("name")
                if not instanceof(self.exp_type, shark_custom_type) then
                    self.write_error("expected a custom type in attribute lookup.")
                    self.error()
                else if not self.exp_type.namespace.has(name) then
                    self.write_error("'")
                    self.write_error(self.exp_type.name)
                    self.write_error("' has no attribute '")
                    self.write_error(name)
                    self.write_error("'.")
                    self.error()
                else
                    var value = self.exp_type.namespace.get(name)
                    if instanceof(value, shark_function) and self.match("(") then
                        var callee = self.callee
                        self.callee=value
                        self.call_args()
                        self.exp_type=self.callee.type
                        self.backend.call_method(self.callee)
                        self.callee=callee
                    else if instanceof(value, shark_variable) then
                        var variable = value
                        self.exp_type=value.type
                        if self.match_inc() then
                            self.backend.inc_field(variable, self.assign_op)
                        else if self.match_assign() then
                            self.backend.set_field(variable, self.assign_op)
                        else
                            self.backend.get_field(variable)
                    else
                        self.write_error("invalid syntax.")
                        self.error()
            else
                break
        return exp
    function call_args()
        self.backend.enter_call()
        var arg_count = 0
        if not self.match(")") then
            self.exp()
            if arg_count<self.callee.arg_names.size() then
                if not self.callee.arg_types.get(arg_count).get_cast(self.exp_type) then
                    self.write_error("invalid type in argument passing.")
                    self.error()
            arg_count+=1
            self.backend.push_arg()
            while self.match(",") do
                self.exp()
                if arg_count<=self.callee.arg_names.size() then
                    if not self.callee.arg_types.get(arg_count).get_cast(self.exp_type) then
                        self.write_error("invalid type in argument passing.")
                        self.error()
                arg_count+=1
                self.backend.push_arg()
            self.expect(")")
        if self.callee.arg_names.size()!=arg_count then
            self.write_error("arity mismatch in function call. (expected ")
            self.write_error(itos(self.callee.arg_names.size()))
            self.write_error(" arguments but got ")
            self.write_error(itos(arg_count))
            self.write_error(").")
            self.error()
    function primary_exp()
        if self.literal() then
            return true
        else if self.token.type=="name" then
            var name = self.next()
            var context = self.context
            while context!=null do
                if context.has(name) then
                    break
                context=context.parent
            if context!=null then
                self.exp_type=context.get(name).type
                if self.match_inc() then
                    self.backend.inc_local(name, self.assign_op)
                else if self.match_assign() then
                    self.backend.set_local(name, self.assign_op)
                else
                    self.backend.get_local(name)
            else if not self.namespace.has(name) then
                self.write_error("name '")
                self.write_error(name)
                self.write_error("' is not defined.")
                self.error()
            else if instanceof(self.namespace.get(name), shark_function) and self.match("(") then
                var callee = self.callee
                self.callee=self.namespace.get(name)
                self.call_args()
                self.exp_type=self.callee.type
                self.callee=callee
                self.backend.call_function(name)
            else if instanceof(self.namespace.get(name), shark_variable) then
                self.exp_type=self.namespace.get(name).type
                if self.match_inc() then
                    self.backend.inc_global(name, self.assign_op)
                else if self.match_assign() then
                    self.backend.set_global(name, self.assign_op)
                else
                    self.backend.get_global(name)
            else
                self.write_error("name '")
                self.write_error(name)
                self.write_error("' is not a variable.")
                self.error()
            return true
        else if self.match("self") then
            if not self.in_type then
                self.write_error("'self' outside class.")
                self.error()
            self.exp_type=self.type_context
            self.backend.self_exp()
            return true
        else if self.match("sizeof") then
            self.expect("(")
            self.exp()
            if not instanceof(self.exp_type, shark_array_type) then
                self.write_error("can't get the size of a non array value.")
                self.error()
            self.exp_type=shark_basic_type_int
            self.expect(")")
            self.backend.sizeof_exp()
            return true
        else if self.match("new") then
            if self.match("[") then
                self.exp()
                if self.exp_type!=shark_basic_type_int then
                    self.write_error("array size should be an integer.")
                    self.error()
                self.expect("]")
                var type = self.type()
                self.exp_type=new shark_array_type(type)
                self.backend.array_new(self.exp_type)
            else
                var type = self.custom_type()
                if type.constructor==null then
                    self.write_error("can't instantiate type (no constructor defined).")
                    self.error()
                var callee = self.callee
                self.callee=type.constructor
                self.expect("(")
                self.call_args()
                self.callee=callee
                self.exp_type=type
                self.backend.object_new(type)
            return true
        else if self.match("instanceof") then
            self.expect("(")
            self.exp()
            if not instanceof(self.exp_type, shark_custom_type) and self.exp_type!=shark_basic_type_any then
                self.write_error("can't test membership of a non object value.")
                self.error()
            self.expect(",")
            var type = self.custom_type()
            self.expect(")")
            self.exp_type=shark_basic_type_bool
            self.backend.instanceof_exp(type)
            return true
        else if self.match("cast") then
            self.expect("(")
            self.exp()
            self.expect(",")
            var type = self.type()
            self.expect(")")
            self.exp_type=type
            self.backend.cast_exp(type)
            return true
        else if self.match("(") then
            self.exp()
            self.expect(")")
            self.backend.nested_exp()
            return true
        else
            return false
    function literal()
        if self.match("null") then
            self.exp_type=shark_basic_type_void
            self.backend.null_exp()
        else if self.match("true") then
            self.exp_type=shark_basic_type_bool
            self.backend.true_exp()
        else if self.match("false") then
            self.exp_type=shark_basic_type_bool
            self.backend.false_exp()
        else if self.token.type=="int" then
            var value = self.next()
            self.exp_type=shark_basic_type_int
            self.backend.int_exp(value)
        else if self.token.type=="float" then
            var value = self.next()
            self.exp_type=shark_basic_type_float
            self.backend.float_exp(value)
        else if self.token.type=="char" then
            var value = self.next()
            self.exp_type=shark_basic_type_char
            self.backend.char_exp(value)
        else if self.token.type=="str" then
            var value = self.next()
            self.exp_type=shark_basic_type_str
            self.backend.str_exp(value)
        else
            return false
        return true
    function optional_exp()
        return self.binary_op(0)
    function exp()
        var prev_assign_target = self.assign_target
        self.assign_target=false
        if not self.binary_op(0) then
            self.write_error("expected expression.")
            self.error()
        self.assign_target=prev_assign_target
function main(args)
    if sizeof(args)<4 then
        write("usage: ")
        write(args[0])
        write(" <backend> <filename> <out> <include>\n")
        write("\tCompiles the given <filename> to <out>.\n")
        write("\t<backend> can be any of <c | java | py | lua | js | shk>.\n")
        write("\t<include> can be zero or more directories to search for include files.\n")
        return
    else
        var root = shark_path_get_base(args[0])
        var target = args[1]
        var filename = args[2]
        var compiler = new shark_compiler()
        var include = new list()
        include.push(shark_path_join(root, "include"))
        include.push(shark_path_get_base(filename))
        if true then
            var i = 4
            while i<sizeof(args) do
                include.push(args[i])
                i+=1
        var backend = null
        if target=="c" then
            backend=new shark_backend_c()
        else if target=="java" then
            backend=new shark_backend_java()
        else if target=="js" then
            backend=new shark_backend_javascript()
        else if target=="lua" then
            backend=new shark_backend_lua()
        else if target=="py" then
            backend=new shark_backend_python()
        else if target=="shk" then
            backend=new shark_backend_shark()
        else
            write("can't recognize the desired backend '")
            write(target)
            write("', compilation aborted.")
            return
        compiler.compile(filename, include, backend, args[3])
        write("====\ncompilation finished")
